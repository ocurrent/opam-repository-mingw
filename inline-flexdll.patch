--- ./flexdll/Compat401.ml
+++ ./flexdll/Compat401.ml
@@ -0,0 +1,10 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+(* Introduced in 4.01.0 *)
+let ( |> ) x f = f x
--- ./flexdll/Compat402.ml
+++ ./flexdll/Compat402.ml
@@ -0,0 +1,20 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+(* Back-port required functionality from Bytes in 4.02.0 *)
+type bytes = string
+module Bytes = struct
+  include String
+
+  let blit_string = blit
+  let sub_string = sub
+  let of_string x = x
+  let to_string x = x
+  let cat = (^)
+end
+let output_bytes = output_string
--- ./flexdll/Compat403.ml
+++ ./flexdll/Compat403.ml
@@ -0,0 +1,45 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+module Char = struct
+  include Char
+
+  (* Taken from 4.03.0 *)
+  let lowercase_ascii c =
+    if (c >= 'A' && c <= 'Z')
+    then unsafe_chr(code c + 32)
+    else c
+
+  let uppercase_ascii c =
+    if (c >= 'a' && c <= 'z')
+    then unsafe_chr(code c - 32)
+    else c
+end
+
+module String = struct
+  include String
+
+  let (lowercase_ascii, uppercase_ascii) =
+    (* Taken from 4.03.0 (not available before 4.00.0) *)
+    let map f s =
+      let l = length s in
+        if l = 0 then s else begin
+          (* create and unsafe_set trigger an irrelevant deprecation warning on 4.02.x *)
+          let r = create l in
+          for i = 0 to l - 1 do unsafe_set r i (f (unsafe_get s i)) done;
+          r
+        end
+    in
+      (map Char.lowercase_ascii, map Char.uppercase_ascii)
+end
+
+module Uchar = struct
+  let unsafe_of_int c = c
+
+  let to_int c = c
+end
--- ./flexdll/Compat405.ml
+++ ./flexdll/Compat405.ml
@@ -0,0 +1,45 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+module Arg = struct
+  include Arg
+
+  (* Taken from 4.05.0 (not available before 4.05.0) *)
+  let trim_cr s =
+    let len = String.length s in
+    if len > 0 && String.get s (len - 1) = '\r' then
+      String.sub s 0 (len - 1)
+    else
+      s
+
+  let read_aux trim sep file =
+    let ic = open_in_bin file in
+    let buf = Buffer.create 200 in
+    let words = ref [] in
+    let stash () =
+      let word = Buffer.contents buf in
+      let word = if trim then trim_cr word else word in
+      words := word :: !words;
+      Buffer.clear buf
+    in
+    begin
+      try while true do
+          let c = input_char ic in
+          if c = sep then stash () else Buffer.add_char buf c
+        done
+      with End_of_file -> ()
+    end;
+    if Buffer.length buf > 0 then stash ();
+    close_in ic;
+    Array.of_list (List.rev !words)
+
+  let read_arg = read_aux true '\n'
+
+  let read_arg0 = read_aux false '\x00'
+
+end
--- ./flexdll/Compat406.ml
+++ ./flexdll/Compat406.ml
@@ -0,0 +1,30 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+module Buffer = struct
+  include Buffer
+
+  (* Strictly speaking this should be in Compat402.ml *)
+  let to_bytes = contents
+
+  (* Taken from 4.06.0 *)
+  let add_utf_16le_uchar b u = match Uchar.to_int u with
+  | u when u < 0 -> assert false
+  | u when u <= 0xFFFF ->
+      Buffer.add_char b (Char.unsafe_chr (u land 0xFF));
+      Buffer.add_char b (Char.unsafe_chr (u lsr 8))
+  | u when u <= 0x10FFFF ->
+      let u' = u - 0x10000 in
+      let hi = 0xD800 lor (u' lsr 10) in
+      let lo = 0xDC00 lor (u' land 0x3FF) in
+      Buffer.add_char b (Char.unsafe_chr (hi land 0xFF));
+      Buffer.add_char b (Char.unsafe_chr (hi lsr 8));
+      Buffer.add_char b (Char.unsafe_chr (lo land 0xFF));
+      Buffer.add_char b (Char.unsafe_chr (lo lsr 8))
+  | _ -> assert false
+end
--- ./flexdll/Compat407.ml
+++ ./flexdll/Compat407.ml
@@ -0,0 +1,9 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+module Stdlib = Pervasives
--- ./flexdll/Makefile
+++ ./flexdll/Makefile
@@ -0,0 +1,327 @@
+## Tips to build flexdll:
+##
+##  To use an already configured 64-bit MSVC toolchain:
+##     make all MSVC_DETECT=0 CHAINS="mingw mingw64 cygwin cygwin64 msvc64"
+##
+
+
+VERSION = 0.40fdopen2
+all: flexlink.exe support
+
+OCAML_CONFIG_FILE=$(shell cygpath -ad "$(shell ocamlopt -where)/Makefile.config")
+include $(OCAML_CONFIG_FILE)
+OCAMLOPT=ocamlopt
+OCAML_VERSION:=$(shell $(OCAMLOPT) -version|sed -e "s/+.*//" -e "s/\.//g")
+ifeq ($(OCAML_VERSION),)
+OCAML_VERSION:=0
+endif
+
+MINGW_PREFIX = i686-w64-mingw32-
+MINCC = $(MINGW_PREFIX)gcc
+
+MINGW64_PREFIX = x86_64-w64-mingw32-
+MIN64CC = $(MINGW64_PREFIX)gcc
+
+CYGWIN_PREFIX = i686-pc-cygwin-
+CYGCC = $(CYGWIN_PREFIX)gcc
+
+CYGWIN64_PREFIX = x86_64-pc-cygwin-
+CYG64CC = $(CYGWIN64_PREFIX)gcc
+
+version.ml: Makefile
+	echo "let version = \"$(VERSION)\"" > version.ml
+	echo "let mingw_prefix = \"$(MINGW_PREFIX)\"" >> version.ml
+	echo "let mingw64_prefix = \"$(MINGW64_PREFIX)\"" >> version.ml
+
+# Supported tool-chains
+
+CHAINS = mingw mingw64 cygwin cygwin64 msvc msvc64
+
+# Compilers
+
+# NB MSVC_DETECT is expected by OCaml's build system
+MSVC_DETECT=1
+
+# Attempt to locate the Windows SDK
+
+ifeq ($(MSVC_DETECT),1)
+ifeq ($(findstring clean,$(MAKECMDGOALS)),)
+include Makefile.winsdk
+endif
+endif
+
+Makefile.winsdk: msvs-detect
+	bash ./msvs-detect --output=make > $@
+
+MSVC_FLAGS=/nologo /MD -D_CRT_SECURE_NO_DEPRECATE /GS-
+
+ifeq ($(MSVC_DETECT),0)
+# Assume that the environment is correctly set for a single Microsoft C Compiler; don't attempt to guess anything
+MSVC_PREFIX=
+MSVC64_PREFIX=
+MSVCC=cl.exe $(MSVC_FLAGS)
+MSVCC64=cl.exe $(MSVC_FLAGS)
+else
+ifeq ($(MSVS_PATH),)
+# Otherwise, assume the 32-bit version of VS 2008 or Win7 SDK is in the path.
+
+MSVCC_ROOT := $(shell which cl.exe 2>/dev/null | cygpath -f - -ad | xargs -d \\n dirname 2>/dev/null | cygpath -f - -m)
+MSVC_LIB1 = $(shell dirname $(MSVCC_ROOT))
+MSVC_LIB2 = $(shell which ResGen.exe | cygpath -f - -ad | xargs -d \\n dirname | xargs -d \\n dirname | cygpath -f - -m)
+MSVC_LIB = $(MSVC_LIB1)/Lib;$(MSVC_LIB2)/Lib
+MSVC_INCLUDE = $(MSVC_LIB1)/Include;$(MSVC_LIB2)/Include
+MSVC_PREFIX=LIB="$(MSVC_LIB)" INCLUDE="$(MSVC_INCLUDE)"
+
+MSVC64_LIB = $(MSVC_LIB1)/Lib/amd64;$(MSVC_LIB2)/Lib/x64
+MSVC64_PREFIX=LIB="$(MSVC64_LIB)" INCLUDE="$(MSVC_INCLUDE)"
+
+MSVCC = $(MSVCC_ROOT)/cl.exe $(MSVC_FLAGS)
+MSVCC64 = $(MSVCC_ROOT)/amd64/cl.exe $(MSVC_FLAGS)
+else
+MSVCC_ROOT:=
+MSVC_PREFIX=PATH="$(MSVS_PATH)$(PATH)" LIB="$(MSVS_LIB)$(LIB)" INCLUDE="$(MSVS_INC)$(INCLUDE)"
+MSVC64_PREFIX=PATH="$(MSVS64_PATH)$(PATH)" LIB="$(MSVS64_LIB)$(LIB)" INCLUDE="$(MSVS64_INC)$(INCLUDE)"
+
+MSVCC = cl.exe $(MSVC_FLAGS)
+MSVCC64 = cl.exe $(MSVC_FLAGS)
+endif
+endif
+
+show_root:
+ifeq ($(MSVCC_ROOT),)
+	@echo "$(MSVS_PATH)"
+	@echo "$(MSVS_LIB)"
+else
+	@echo "$(MSVCC_ROOT)"
+	@echo "$(MSVC_LIB)"
+endif
+
+OCAMLOPT = ocamlopt -g
+
+#OCAMLOPT += -strict-sequence -strict-formats -safe-string -w +A-9
+
+#OCAMLOPT = FLEXLINKFLAGS=-real-manifest ocamlopt
+#LINKFLAGS = unix.cmxa
+
+ifeq ($(TOOLCHAIN), msvc)
+RES=version.res
+ifeq ($(ARCH), i386)
+RES_PREFIX=$(MSVC_PREFIX)
+else
+RES_PREFIX=$(MSVC64_PREFIX)
+endif
+else
+RES=version_res.o
+RES_PREFIX=
+endif
+
+ifeq ($(NATDYNLINK), false)
+#when ocaml is not built with flexlink i.e. -no-shared-libs
+LINKFLAGS = -cclib "$(RES)"
+else
+LINKFLAGS = -cclib "-link $(RES)"
+endif
+
+support:
+	for i in $(CHAINS); do $(MAKE) --no-print-directory build_$$i || break ; done
+
+build_gnat: flexdll_gnat.o flexdll_initer_gnat.o
+build_msvc: flexdll_msvc.obj flexdll_initer_msvc.obj
+build_msvc64: flexdll_msvc64.obj flexdll_initer_msvc64.obj
+build_cygwin: flexdll_cygwin.o flexdll_initer_cygwin.o
+build_cygwin64: flexdll_cygwin64.o flexdll_initer_cygwin64.o
+build_mingw: flexdll_mingw.o flexdll_initer_mingw.o
+build_mingw64: flexdll_mingw64.o flexdll_initer_mingw64.o
+
+OBJS = version.ml Compat.ml coff.ml cmdline.ml create_dll.ml reloc.ml
+
+COMPILER-$(OCAML_VERSION):
+	rm -f COMPILER-*
+	touch COMPILER-$(OCAML_VERSION)
+
+test_ver = $(shell if [ $(OCAML_VERSION) -lt $(1) ] ; then echo lt ; fi)
+
+# This list must be in order
+COMPAT_MODULES := $(if $(call test_ver,4010),Compat401) \
+                  $(if $(call test_ver,4020),Compat402) \
+                  $(if $(call test_ver,4030),Compat403) \
+                  $(if $(call test_ver,4050),Compat405) \
+                  $(if $(call test_ver,4060),Compat406) \
+                  $(if $(call test_ver,4070),Compat407)
+
+Compat.ml: COMPILER-$(OCAML_VERSION) $(addsuffix .ml, $(COMPAT_MODULES))
+	cat $^ > $@
+
+flexlink.exe: $(OBJS) $(RES)
+	@echo Building flexlink.exe with TOOLCHAIN=$(TOOLCHAIN) for OCaml $(OCAML_VERSION)
+	rm -f flexlink.exe
+	$(RES_PREFIX) $(OCAMLOPT) -o flexlink.exe $(LINKFLAGS) $(OBJS)
+
+version.res: version.rc
+	$(RES_PREFIX) rc version.rc
+
+version_res.o: version.rc
+	$(TOOLPREF)windres version.rc version_res.o
+
+flexdll_msvc.obj: flexdll.h flexdll.c
+	$(MSVC_PREFIX) $(MSVCC) /DMSVC -c /Fo"flexdll_msvc.obj" flexdll.c
+	@mkdir -p ../lib/ocaml/flexdll
+	@if [ ! -f ../lib/ocaml/flexdll/flexdll.h ]; then cp default.manifest flexdll.h ../lib/ocaml/flexdll ; fi
+	@cp $@ ../lib/ocaml/flexdll
+
+flexdll_msvc64.obj: flexdll.h flexdll.c
+	$(MSVC64_PREFIX) $(MSVCC64) /DMSVC /DMSVC64 -c /Fo"flexdll_msvc64.obj" flexdll.c
+	@mkdir -p ../lib/ocaml/flexdll
+	@if [ ! -f ../lib/ocaml/flexdll/flexdll.h ]; then cp default_amd64.manifest flexdll.h ../lib/ocaml/flexdll ; fi
+	@cp $@ ../lib/ocaml/flexdll
+
+flexdll_cygwin.o: flexdll.h flexdll.c
+	$(CYGCC) -c -DCYGWIN -o flexdll_cygwin.o flexdll.c
+
+flexdll_cygwin64.o: flexdll.h flexdll.c
+	$(CYG64CC) -c -DCYGWIN -o flexdll_cygwin64.o flexdll.c
+
+flexdll_mingw.o: flexdll.h flexdll.c
+	$(MINCC) -c -DMINGW -o flexdll_mingw.o flexdll.c
+	@mkdir -p ../lib/ocaml/flexdll
+	@if [ ! -f ../lib/ocaml/flexdll/flexdll.h ]; then cp default.manifest flexdll.h ../lib/ocaml/flexdll ; fi
+	@cp $@ ../lib/ocaml/flexdll
+
+flexdll_gnat.o: flexdll.h flexdll.c
+	gcc -c -o flexdll_gnat.o flexdll.c
+
+flexdll_mingw64.o: flexdll.h flexdll.c
+	$(MIN64CC) -c -DMINGW -o flexdll_mingw64.o flexdll.c
+	@mkdir -p ../lib/ocaml/flexdll
+	@if [ ! -f ../lib/ocaml/flexdll/flexdll.h ]; then cp default_amd64.manifest flexdll.h ../lib/ocaml/flexdll ; fi
+	@cp $@ ../lib/ocaml/flexdll
+
+flexdll_initer_msvc.obj: flexdll_initer.c
+	$(MSVC_PREFIX) $(MSVCC) -c /Fo"flexdll_initer_msvc.obj" flexdll_initer.c
+	@mkdir -p ../lib/ocaml/flexdll
+	@if [ ! -f ../lib/ocaml/flexdll/flexdll.h ]; then cp default.manifest flexdll.h ../lib/ocaml/flexdll ; fi
+	@cp $@ ../lib/ocaml/flexdll
+
+flexdll_initer_msvc64.obj: flexdll_initer.c
+	$(MSVC64_PREFIX) $(MSVCC64) -c /Fo"flexdll_initer_msvc64.obj" flexdll_initer.c
+	@mkdir -p ../lib/ocaml/flexdll
+	@if [ ! -f ../lib/ocaml/flexdll/flexdll.h ]; then cp default_amd64.manifest flexdll.h ../lib/ocaml/flexdll ; fi
+	@cp $@ ../lib/ocaml/flexdll
+
+flexdll_initer_cygwin.o: flexdll_initer.c
+	$(CYGCC) -c -o flexdll_initer_cygwin.o flexdll_initer.c
+
+flexdll_initer_cygwin64.o: flexdll_initer.c
+	$(CYG64CC) -c -o flexdll_initer_cygwin64.o flexdll_initer.c
+
+flexdll_initer_mingw.o: flexdll_initer.c
+	$(MINCC) -c -o flexdll_initer_mingw.o flexdll_initer.c
+	@mkdir -p ../lib/ocaml/flexdll
+	@if [ ! -f ../lib/ocaml/flexdll/flexdll.h ]; then cp default.manifest flexdll.h ../lib/ocaml/flexdll ; fi
+	@cp $@ ../lib/ocaml/flexdll
+
+flexdll_initer_gnat.o: flexdll_initer.c
+	gcc -c -o flexdll_initer_gnat.o flexdll_initer.c
+
+flexdll_initer_mingw64.o: flexdll_initer.c
+	$(MIN64CC) -c -o flexdll_initer_mingw64.o flexdll_initer.c
+	@mkdir -p ../lib/ocaml/flexdll
+	@if [ ! -f ../lib/ocaml/flexdll/flexdll.h ]; then cp default_amd64.manifest flexdll.h ../lib/ocaml/flexdll ; fi
+	@cp $@ ../lib/ocaml/flexdll
+
+
+demo_msvc: flexlink.exe flexdll_msvc.obj flexdll_initer_msvc.obj
+	$(MSVC_PREFIX) $(MAKE) -C test clean demo CHAIN=msvc CC="$(MSVCC)" PLUG2_CFLAGS="/bigobj" O=obj
+
+demo_cygwin: flexlink.exe flexdll_cygwin.o flexdll_initer_cygwin.o
+	$(MAKE) -C test clean demo CHAIN=cygwin CC="$(CYGCC)" O=o
+
+demo_cygwin64: flexlink.exe flexdll_cygwin64.o flexdll_initer_cygwin64.o
+	$(MAKE) -C test clean demo CHAIN=cygwin64 CC="$(CYG64CC)" O=o RUN="PATH=\"/cygdrive/c/cygwin64/bin:$(PATH)\""
+
+demo_mingw: flexlink.exe flexdll_mingw.o flexdll_initer_mingw.o
+	$(MAKE) -C test clean demo CHAIN=mingw CC="$(MINCC)" O=o
+
+demo_mingw64: flexlink.exe flexdll_mingw64.o flexdll_initer_mingw64.o
+	$(MAKE) -C test clean demo CHAIN=mingw64 CC="$(MIN64CC)" O=o
+
+demo_msvc64:  flexlink.exe flexdll_msvc64.obj flexdll_initer_msvc64.obj
+	$(MSVC64_PREFIX) $(MAKE) -C test clean demo CHAIN=msvc64 CC="$(MSVCC64)" PLUG2_CFLAGS="/bigobj" O=obj
+
+distclean: clean
+	rm -f Makefile.winsdk
+
+clean:
+	rm -f *.obj *.o *.lib *.a *.exe *.opt *.cmx *.dll *.exp *.cmi *.cmo *~ version.res version.ml COMPILER-* Compat.ml
+	cd test && $(MAKE) clean
+
+
+## Packaging
+
+COMMON_FILES = LICENSE README.md CHANGES flexdll.h flexdll.c flexdll_initer.c default.manifest default_amd64.manifest
+URL = frisch@frisch.fr:www/flexdll/
+
+# Source packages
+
+PACKAGE = flexdll-$(VERSION).tar.gz
+
+package_src:
+	rm -Rf flexdll-$(VERSION)
+	mkdir flexdll-$(VERSION)
+	mkdir flexdll-$(VERSION)/test
+	cp -a $(filter-out Compat.ml version.ml,$(OBJS) $(shell git ls-files Compat*.ml)) Makefile msvs-detect $(COMMON_FILES) version.rc flexdll-$(VERSION)/
+	cp -aR test/Makefile test/*.c flexdll-$(VERSION)/test/
+	tar czf $(PACKAGE) flexdll-$(VERSION)
+	rm -Rf flexdll-$(VERSION)
+
+upload:
+	rsync $(PACKAGE) CHANGES LICENSE $(URL)
+
+upload_dev:
+	$(MAKE) VERSION=dev upload_src
+
+upload_src: package_src upload
+
+# Binary package
+
+PACKAGE_BIN = flexdll-bin-$(VERSION)$(PACKAGE_BIN_SUFFIX).zip
+INSTALLER = flexdll-$(VERSION)$(PACKAGE_BIN_SUFFIX)-setup.exe
+
+package_bin:
+	$(MAKE) clean all
+	rm -f $(PACKAGE_BIN)
+	zip $(PACKAGE_BIN) $(COMMON_FILES) \
+	    flexlink.exe flexdll_*.obj flexdll_*.o flexdll.c flexdll_initer.c
+
+do_upload_bin:
+	rsync $(PACKAGE_BIN) $(URL)
+
+upload_bin: package_bin do_upload_bin
+
+show_toolchain:
+	@echo Toolchain for the visible ocamlopt: $(TOOLCHAIN)
+
+swap:
+	$(OCAMLOPT) -o flexlink-new.exe $(LINKFLAGS) $(OBJS)
+	cp flexlink.exe flexlink.exe.bak
+	cp flexlink-new.exe flexlink.exe
+
+PREFIX = "C:\Program Files (x86)\flexdll"
+
+install:
+	mkdir -p $(PREFIX)
+	cp $(COMMON_FILES) flexlink.exe flexdll_*.obj flexdll_*.o flexdll.c flexdll_initer.c $(PREFIX)
+
+installer:
+	rm -rf flexdll_install_files
+	mkdir flexdll_install_files
+	(cd flexdll_install_files && unzip ../$(PACKAGE_BIN))
+	/cygdrive/c/Program\ Files\ \(x86\)/NSIS/makensis installer.nsi
+	mv flexdll_setup.exe $(INSTALLER)
+
+upload_installer:
+	rsync $(INSTALLER) $(URL)
+
+
+upload_all:
+	$(MAKE) upload_src upload_bin installer upload_installer
--- ./flexdll/cmdline.ml
+++ ./flexdll/cmdline.ml
@@ -0,0 +1,407 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+include Compat
+
+let underscore = ref true
+    (* Are "normal" symbols prefixed with an underscore? *)
+
+let machine : [ `x86 | `x64 ] ref = ref `x86
+
+let noexport = ref false
+let custom_crt = ref false
+let reexport_from_implibs = ref true
+let use_default_libs = ref true
+let subsystem = ref "console"
+let explain = ref false
+let builtin_linker = ref false
+let toolchain : [ `MSVC | `MSVC64 | `MINGW | `MINGW64 | `GNAT | `GNAT64 | `CYGWIN | `CYGWIN64 | `LIGHTLD ] ref = ref `MSVC
+let save_temps = ref false
+let show_exports = ref false
+let show_imports = ref false
+let dry_mode = ref false
+let verbose = ref 0
+let dirs = ref []
+let no_merge_manifest = ref false
+let merge_manifest = ref false
+let real_manifest = ref true
+let add_flexdll_obj = ref true
+let files = ref []
+let exts = ref []
+let output_file = ref ""
+let exe_mode : [`DLL | `EXE | `MAINDLL] ref = ref `DLL
+let extra_args = ref []
+let mode : [`NORMAL | `DUMP | `PATCH] ref = ref `NORMAL
+let defexports = ref []
+let noentry = ref false
+let use_cygpath = ref true
+let cygpath_arg : [`Yes | `No | `None] ref = ref `None
+let implib = ref false
+let deffile = ref None
+let stack_reserve = ref None
+let no_rel_relocs = ref false
+let base_addr = ref "0x10000"
+let oasis_hack = ref true
+
+let flexdir =
+  try
+    let s = Sys.getenv "FLEXDIR" in
+    if s = "" then raise Not_found else s
+  with
+  | Not_found ->
+      let (//) = Filename.concat in
+      (Filename.dirname (Filename.dirname Sys.executable_name))
+      // "lib" // "ocaml" // "flexdll"
+
+let usage_msg =
+  Printf.sprintf
+    "FlexDLL version %s\n\nUsage:\n  flexlink -o <result.dll/exe> file1.obj file2.obj ... -- <extra linker arguments>\n"
+    Version.version
+
+let footer =
+"Notes:
+* The -I, -l and -L options do not need to be separated from their argument.
+* An option like /linkXXX is an abbrevation for '-link XXX'.
+* An option like -Wl,-XXX is an abbreviation for '-link -XXX'.
+* FlexDLL's object files are searched by default in the same directory as
+  flexlink, or in the directory given by the environment variable FLEXDIR
+  if it is defined.
+* Extra argument can be passed in the environment variable FLEXLINKFLAGS.
+
+Homepage: http://alain.frisch.fr/flexdll.html"
+
+let specs = [
+
+  "-o", Arg.Set_string output_file,
+  " Choose the name of the output file";
+
+  "-exe", Arg.Unit (fun () -> exe_mode := `EXE),
+  " Link the main program as an exe file";
+
+  "-maindll", Arg.Unit (fun () -> exe_mode := `MAINDLL),
+  " Link the main program as a dll file";
+
+  "-noflexdllobj", Arg.Clear add_flexdll_obj,
+  " Do not add the Flexdll runtime object (for exe)";
+
+  "-noentry", Arg.Set noentry,
+  " Do not use the Flexdll entry point (for dll)";
+
+  "-noexport", Arg.Set noexport,
+  " Do not export any symbol";
+
+  "-norelrelocs", Arg.Set no_rel_relocs,
+  " Ensure that no relative relocation is generated";
+
+  "-base", Arg.String (fun s -> base_addr := s),
+  " Specify base address (Win64 only)";
+
+  "-I", Arg.String (fun dir -> dirs := dir :: !dirs),
+  "<dir> Add a directory where to search for files";
+
+  "-L", Arg.String (fun dir -> dirs := dir :: !dirs),
+  "<dir> Add a directory where to search for files";
+
+  "-l", Arg.String (fun s -> files := ("-l" ^ s) :: !files),
+  "<lib> Library file";
+
+  "-chain", Arg.Symbol (["msvc";"msvc64";"cygwin";"cygwin64";"mingw";"mingw64";"gnat";"gnat64";"ld"],
+			(fun s ->
+                          machine := `x86; underscore := true;
+                          toolchain := match s with
+			  | "msvc" -> `MSVC
+			  | "msvc64" -> machine := `x64; underscore := false; `MSVC64
+			  | "cygwin" -> `CYGWIN
+			  | "cygwin64" -> machine := `x64; underscore := false; `CYGWIN64
+			  | "mingw" -> `MINGW
+			  | "gnat" -> `GNAT
+			  | "gnat64" -> machine := `x64; underscore := false; `GNAT64
+			  | "mingw64" -> machine := `x64; underscore := false; `MINGW64
+                          | "ld" -> `LIGHTLD
+			  | _ -> assert false)),
+  " Choose which linker to use";
+
+  "-x64", Arg.Unit (fun () -> machine := `x64; underscore := false; toolchain := `MSVC64),
+  " (Deprecated)";
+
+  "-defaultlib", Arg.String (fun s -> exts := s :: !exts),
+  "<obj> External object (no export, no import)";
+
+  "-save-temps", Arg.Set save_temps,
+  " Do not delete intermediate files";
+
+  "-implib", Arg.Set implib,
+  " Do not delete the generated import library";
+
+  "-outdef", Arg.String (fun s -> deffile := Some s),
+  " Produce a def file with exported symbols";
+
+  "-v", Arg.Unit (fun () -> incr verbose),
+  " Increment verbosity (can be repeated)";
+
+  "-show-exports", Arg.Set show_exports,
+  " Show exported symbols";
+
+  "-show-imports", Arg.Set show_imports,
+  " Show imported symbols";
+
+  "-dry", Arg.Set dry_mode,
+  " Show the linker command line, do not actually run it";
+
+  "-dump", Arg.Unit (fun () -> mode := `DUMP),
+  " Only dump the content of object files";
+
+  "-patch", Arg.Unit (fun () -> mode := `PATCH),
+  " Only patch the target image (to be used with -stack)";
+
+  "-nocygpath", Arg.Unit (fun () -> cygpath_arg := `No),
+  " Do not use cygpath (default for msvc, mingw)";
+
+  "-cygpath", Arg.Unit (fun () -> cygpath_arg := `Yes),
+  " Use cygpath (default for cygwin)";
+
+  "-no-merge-manifest", Arg.Set no_merge_manifest,
+  " Do not merge the manifest (takes precedence over -merge-manifest)";
+
+  "-merge-manifest", Arg.Set merge_manifest,
+  " Merge manifest to the dll or exe (if generated)";
+
+  "-real-manifest", Arg.Set real_manifest,
+  " Use the generated manifest (default behavior)";
+
+  "-default-manifest", Arg.Clear real_manifest,
+  " Use the default manifest (default.manifest/default_amd64.manifest)";
+
+  "-export", Arg.String (fun s -> defexports := s :: !defexports),
+  "<sym> Explicitly export a symbol";
+
+  "-noreexport", Arg.Clear reexport_from_implibs,
+  " Do not reexport symbols imported from import libraries";
+
+  "-where", Arg.Unit
+    (fun () ->
+      let slashify =
+        match Sys.win32 with
+        | true -> String.map ( function | '\\' -> '/' | x -> x)
+        | false -> fun id -> id
+      in
+      if Sys.win32 then
+        (try set_binary_mode_out stdout true with _ -> ());
+      slashify flexdir |> print_endline ;
+      exit 0
+    ),
+  " Show the FlexDLL directory";
+
+  "-nounderscore", Arg.Clear underscore,
+  " Normal symbols are not prefixed with an underscore";
+
+  "-nodefaultlibs", Arg.Clear use_default_libs,
+  " Do not assume any default library";
+
+  "-builtin", Arg.Set builtin_linker,
+  " Use built-in linker to produce a dll";
+
+  "-explain", Arg.Set explain,
+  " Explain why library objects are linked";
+
+  "-subsystem", Arg.Set_string subsystem,
+  "<id> Set the subsystem (default: console)";
+
+  "-custom-crt", Arg.Set custom_crt,
+  " Use a custom CRT";
+
+  "-stack", Arg.String (fun s -> try stack_reserve := Some (Int32.of_string s) with _ -> raise (Arg.Bad "integer argument expected for -stack")),
+  "<int> Set the stack reserve in the resulting image";
+
+  "-link", Arg.String (fun s -> extra_args := s :: !extra_args),
+  "<option> Next argument is passed verbatim to the linker";
+
+  "-g", Arg.Unit (fun () -> ()),
+  " (ignored)";
+
+  "-D", Arg.String (fun _ -> ()),
+  "<symbol> (Ignored)";
+
+  "-U", Arg.String (fun _ -> ()),
+  "<symbol> (Ignored)";
+
+  "-pthread", Arg.Unit (fun () -> extra_args := "-pthread" :: !extra_args),
+  "pass -pthread to the linker (gcc toolchain only)";
+
+  "-no-oasis-hack", Arg.Clear oasis_hack,
+  "disable hack for oasis' compiled setup.exe (relevant only for msvc32)";
+
+  "--", Arg.Rest (fun s -> extra_args := s :: !extra_args),
+  " Following arguments are passed verbatim to the linker";
+]
+
+
+let unquote_win str =
+  let len = String.length str in
+  if len < 2 then
+    str
+  else if str.[0] <> '"' || ( str.[len - 1 ] <> '"' && str.[len-1] <> '\\' )  then
+    str
+  else if len = 2 then
+    ""
+  else
+    let b = Buffer.create (len - 2 ) in
+    let rec loop i =
+      if i <= len - 1 then (
+        match str.[i] with
+        | '\\'->  loop_bs 0 i
+        | '"' ->
+          if i <> len - 1 then (
+            if follow_only_bs (succ i) then
+              loop_bs 0 (succ i)
+            else (
+              Buffer.add_char b '"' ;
+              loop (succ i)
+            )
+          )
+        |  c  ->
+          Buffer.add_char b c ;
+          loop (succ i)
+      )
+    and follow_only_bs i =
+      if i >= len then
+        true
+      else
+        match str.[i] with
+        | '\\' ->  follow_only_bs (succ i )
+        | _ -> false
+    and loop_bs n i =
+      if i = len - 1 then (
+        match str.[i] with
+        | '\\'-> add_bs (n+1)
+        | _   -> add_bs n
+      )
+      else (
+        match str.[i] with
+        | '"' ->
+          add_bs (n/2);
+          if follow_only_bs (succ i) = false ; then
+            Buffer.add_char b '"' ;
+          loop (succ i)
+        | '\\' ->
+          loop_bs (succ n) (succ i)
+        | c    ->
+          add_bs n ;
+          loop i
+      )
+    and add_bs n =
+      for j = 1 to n do Buffer.add_char b '\\'; done
+    in
+    loop 1;
+    Buffer.contents b
+
+(* currently, a responsefile is only used by the native version of ocaml,
+ * not the cygwin-based. *)
+let unquote = unquote_win
+
+let flexlinkflags =
+  let s =
+    try Sys.getenv "FLEXLINKFLAGS"
+    with Not_found -> ""
+  in
+  let n = String.length s in
+  let rec skip_ws i = if i < n && s.[i] = ' ' then skip_ws (i + 1) else i in
+  let rec scan_quote i = if i = n then i else if s.[i] = '"' then i + 1 else scan_quote (i+1) in
+  let rec scan_arg i =
+    if i = n || s.[i] = ' ' then i
+    else if s.[i] = '"' then scan_arg (scan_quote (i + 1))
+    else scan_arg (i + 1) in
+  let rec args i =
+    let i = skip_ws i in
+    if i = n then []
+    else let j = scan_arg i in String.sub s i (j - i) :: args j
+  in
+  args 0
+
+let parse_cmdline () =
+  (* Split -lXXX, -LXXX and -IXXX options *)
+  let tosplit = function
+    | "-l" | "-L" | "-I" | "-D" | "-U" -> true
+    | _ -> false
+  in
+  let tolinker = function
+  | "-f" | "-m" | "-O" | "-W" -> true
+  | _ -> false in
+  let rec tr = function
+    | (("-defaultlib"|"-link") as d) :: x :: rest -> d :: x :: tr rest
+    | "/link" :: x :: rest -> "-link" :: x :: tr rest
+    | s :: rest when String.length s > 2 && tosplit (String.sub s 0 2) ->
+        String.sub s 0 2 :: String.sub s 2 (String.length s - 2) :: tr rest
+    | s :: rest when String.length s >= 5 && String.sub s 0 5 = "/link" ->
+        "-link" :: String.sub s 5 (String.length s - 5) :: tr rest
+    (* Convert gcc linker option prefix -Wl, to flexlink linker prefix -link *)
+    | s :: rest when String.length s >= 6 && String.sub s 0 5 = "-Wl,-" ->
+        "-link" :: String.sub s 4 (String.length s - 4) :: tr rest
+    | "-arg" :: x :: rest ->
+        tr (Array.to_list (Arg.read_arg x)) @ rest
+    | "-arg0" :: x :: rest ->
+        tr (Array.to_list (Arg.read_arg0 x)) @ rest
+    | "-pipe" :: rest -> "-link" :: "-pipe" :: tr rest
+    | (("-merge-manifest"|"-maindll")  as d) :: rest -> d :: tr rest
+    | s :: rest when String.length s >= 2 && tolinker (String.sub s 0 2) ->
+        Printf.eprintf "flexlink warning: unsupported flag %S passed verbatim to the linker\n%!" s;
+        "-link" :: s :: tr rest
+    | x :: rest when x <> "" && x.[0] = '-' ->
+        begin
+          try
+            let i = String.index x ':' in
+            String.sub x 0 i :: String.sub x (i + 1) (String.length x - i - 1)
+            :: tr rest
+          with Not_found ->
+            x :: tr rest
+        end
+    | x :: rest -> x :: tr rest
+    | [] -> []
+  in
+  let fresponse accu l =
+    let len = String.length l in
+    if len < 1 then
+      l::accu
+    else if l.[0] <> '@' then
+      l::accu
+    else
+      let fln = String.sub l 1 (pred len ) in
+      if Sys.file_exists fln = false then
+        l::accu
+      else
+        let ch = open_in fln in
+        let naccu =
+          let ac = ref accu in
+        try
+          while true do
+              ac := (unquote (input_line ch) ) :: !ac
+            done;
+            assert false
+          with
+          | End_of_file -> !ac
+        in
+        close_in ch;
+        naccu
+  in
+
+  let args =
+    match List.rev ( Array.fold_left fresponse [] Sys.argv ) with
+    | pgm :: args -> pgm :: tr (flexlinkflags @ args)
+    | _ -> assert false
+  in
+
+
+  Arg.parse_argv (Array.of_list args) (Arg.align specs)
+    (fun x -> files := x :: !files) usage_msg;
+  if !output_file = "" && !mode <> `DUMP then begin
+    Printf.eprintf
+      "Please specify an output file (-help to get some usage information)\n";
+    exit 1
+  end
+
+let usym s = if !underscore then "_" ^ s else s
--- ./flexdll/coff.ml
+++ ./flexdll/coff.ml
@@ -0,0 +1,1070 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+(* This module implements a reader/writer for COFF object files
+   and libraries. *)
+
+include Compat
+
+module Buf : sig
+  type t
+  val create: unit -> t
+  val length: t -> int
+  val dump: out_channel -> t -> unit
+  val string: t -> string -> unit
+  val bytes: t -> bytes -> unit
+  val int8: t -> int -> unit
+  val int32: t -> int32 -> unit
+  val int16: t -> int -> unit
+  val lazy_int32: t -> int32 Lazy.t -> unit
+  val patch_lazy_int32: t -> int -> int32 Lazy.t -> unit
+  val future_int32: t -> int32 Lazy.t -> int32 ref
+  val set_future: t -> int32 ref -> unit
+end = struct
+  type t = {
+      mutable buf: bytes;
+      mutable pos: int;
+      mutable len: int;
+      mutable patches: (unit -> unit) list;
+    }
+
+  let create () =
+    { buf = Bytes.create 16;
+      pos = 0;
+      len = 16;
+      patches = [] }
+
+  let ensure b n =
+    let len = ref b.len in
+    let pos = b.pos in
+    if n > Sys.max_string_length then
+     failwith (Printf.sprintf "Cannot grow string buffer to len %i.\n" n);
+    while n > !len do len := !len * 2 done;
+    if !len > Sys.max_string_length then len := Sys.max_string_length;
+    let nbuf = Bytes.create !len in
+    Bytes.blit b.buf 0 nbuf 0 pos;
+    b.buf <- nbuf;
+    b.len <- !len
+
+  let int8 b x =
+    let pos = b.pos in
+    if pos = b.len then begin
+      let nlen = b.len * 2 in
+      let nbuf = Bytes.create nlen in
+      Bytes.blit b.buf 0 nbuf 0 pos;
+      b.buf <- nbuf;
+      b.len <- nlen
+    end;
+    Bytes.set b.buf pos (Char.chr (x land 0xff));
+    b.pos <- succ pos
+
+  let int16 b x =
+    int8 b x;
+    int8 b (x asr 8)
+
+  let length b = b.pos
+
+  let patch b =
+    List.iter (fun f -> f ()) b.patches;
+    b.patches <- []
+
+  let add_patch b f =
+    b.patches <- f :: b.patches
+
+  let dump oc b =
+    patch b;
+    output_bytes oc (Bytes.sub b.buf 0 b.pos)
+
+  let string b s =
+    let l = String.length s in
+    let r = b.pos + l in
+    if r > b.len then ensure b r;
+    Bytes.blit_string s 0 b.buf b.pos l;
+    b.pos <- r
+
+  let bytes b s =
+    let l = Bytes.length s in
+    let r = b.pos + l in
+    if r > b.len then ensure b r;
+    Bytes.blit s 0 b.buf b.pos l;
+    b.pos <- r
+
+  let blit_int32 s pos i =
+    Bytes.set s pos (Char.chr ((Int32.to_int i) land 0xff));
+    Bytes.set s (pos+1) (Char.chr ((Int32.to_int (Int32.shift_right i 8)) land 0xff));
+    Bytes.set s (pos+2) (Char.chr ((Int32.to_int (Int32.shift_right i 16)) land 0xff));
+    Bytes.set s (pos+3) (Char.chr ((Int32.to_int (Int32.shift_right i 24)) land 0xff))
+
+  let int32 b i =
+    let r = b.pos + 4 in
+    if r > b.len then ensure b r;
+    blit_int32 b.buf b.pos i;
+    b.pos <- r
+
+  let lazy_int32 b i =
+    let pos = b.pos in
+    let r = b.pos + 4 in
+    if r > b.len then ensure b r;
+    b.pos <- r;
+    add_patch b (fun () -> blit_int32 b.buf pos (Lazy.force i))
+
+  let patch_lazy_int32 b pos i =
+    add_patch b (fun () -> blit_int32 b.buf pos (Lazy.force i))
+
+  let future_int32 b ofs =
+    let r = ref 0l in
+    lazy_int32 b (lazy (Int32.add !r (Lazy.force ofs)));
+    r
+
+  let set_future b r =
+    r := Int32.of_int (length b)
+end
+
+
+(* Internal representation of COFF object files *)
+
+type symbol = {
+  mutable sym_pos: int;
+  mutable sym_name: string;
+  mutable value: int32;
+  mutable section: [ `Num of int | `Section of section ];
+  stype: int;
+  storage: int;
+  auxn: int;
+  mutable auxs: bytes;
+  mutable extra_info: [ `Alias of symbol | `Section of section | `None ];
+}
+
+and reloc = {
+  addr: int32;
+  symbol: symbol;
+  rtype: int;
+}
+
+and section = {
+  mutable sec_pos: int;
+  mutable sec_name: string;
+  mutable vsize: int32;
+  mutable vaddress: int32;
+  mutable data:
+      [ `String of bytes | `Uninit of int
+    | `Buf of Buf.t list
+    | `Lazy of in_channel * int * int
+    | `Sxdata of symbol array
+];
+  mutable relocs: reloc list;
+  mutable sec_opts: int32;
+}
+
+type coff = {
+  bigobj: bool;
+  obj_name: string;
+  machine: int;
+  date: int32;
+  mutable sections: section list;
+  mutable symbols: symbol list;
+  opts: int;
+}
+
+(* Misc *)
+
+
+let (++) = Int32.add
+let (&&&) = Int32.logand
+let (|||) = Int32.logor
+let (>>>) = Int32.shift_right_logical
+
+let filter f l =
+  let rec aux accu = function
+    | [] -> accu
+    | hd::tl -> if f hd then aux (hd::accu) tl else aux accu tl
+  in
+  aux [] l
+
+let is_zero s =
+  try
+    for i = 0 to String.length s - 1 do
+      if s.[i] <> '\000' then raise Exit
+    done;
+    true
+  with Exit -> false
+
+(* Tools to read/write binary data *)
+
+let mk_int32 a b c d =
+  let a = Int32.of_int a
+  and b = Int32.shift_left (Int32.of_int b) 8
+  and c = Int32.shift_left (Int32.of_int c) 16
+  and d = Int32.shift_left (Int32.of_int d) 24 in
+  a ++ b ++ c ++ d
+
+let read ic pos len =
+  if len = 0 then Bytes.of_string ""
+  else (
+    seek_in ic pos;
+    let buf = Bytes.create len in
+    really_input ic buf 0 len;
+    buf
+  )
+
+let read_str ic pos len =
+  Bytes.to_string (read ic pos len)
+
+let int32 buf loc =
+  mk_int32
+    (Char.code (Bytes.get buf loc)) (Char.code (Bytes.get buf (loc + 1)))
+    (Char.code (Bytes.get buf (loc + 2))) (Char.code (Bytes.get buf (loc + 3)))
+
+let emit_int32 oc i =
+  output_byte oc (Int32.to_int (i &&& 0xffl));
+  output_byte oc (Int32.to_int ((i >>> 8) &&& 0xffl));
+  output_byte oc (Int32.to_int ((i >>> 16) &&& 0xffl));
+  output_byte oc (Int32.to_int ((i >>> 24) &&& 0xffl))
+
+let patch_int32 oc pos i =
+  let bak = pos_out oc in
+  seek_out oc pos;
+  emit_int32 oc i;
+  seek_out oc bak
+
+let emit_int16 oc i =
+  output_byte oc (i land 0xff);
+  output_byte oc (i lsr 8)
+
+let emit_int8 = output_byte
+
+let int32_ buf loc = Int32.to_int (int32 buf loc)
+
+let int16 buf loc = Char.code (Bytes.get buf loc) + (Char.code (Bytes.get buf (loc + 1))) lsl 8
+
+let int8 buf loc = Char.code (Bytes.get buf loc)
+
+let strz buf loc ?(max=Bytes.length buf - loc) c =
+  let i =
+    try Bytes.index_from buf loc c
+    with Not_found -> Bytes.length buf in
+  Bytes.sub_string buf loc (min max (i - loc))
+
+let emit_zero oc n =
+  for _i = 1 to n do output_char oc '\000' done
+
+let delayed_ptr oc f =
+  let bak = pos_out oc in
+  emit_int32 oc 0l;
+  (fun () ->
+     patch_int32 oc bak (Int32.of_int (pos_out oc));
+     f ()
+  )
+
+let force_section_data sec =
+  match sec.data with
+    | `Lazy (ic,pos,len) ->
+        let r = `String (read ic pos len) in
+        sec.data <- r;
+        r
+    | x -> x
+
+let copy_data ic pos oc len =
+  (* TODO: bufferized copy when len > threshold *)
+  output_bytes oc (read ic pos len)
+
+(* Human readable pretty-printers *)
+
+let flags x =
+  let b = Buffer.create 16 in
+  for i = 0 to 31 do
+    let m = Int32.shift_left 1l i in
+      if m &&& x <> 0l then
+        Printf.bprintf b "0x%08lx " m
+  done;
+  Buffer.contents b
+
+let rec dump ic pos len w =
+  if len = 0 then (Printf.printf "---\n"; flush stdout)
+  else let l = min len w in
+  let b = read ic pos l in
+  Printf.printf "%08x: " pos;
+  for i = 0 to l - 1 do Printf.printf "%02x " (Char.code (Bytes.get b i)) done;
+  for _i = l to w - 1 do Printf.printf "   " done;
+  Printf.printf " ";
+  for i = 0 to l - 1 do match Bytes.get b i with
+    | '\032'..'\127' as c -> print_char c
+    | _ -> print_char '.'
+  done;
+  Printf.printf "\n%!";
+  dump ic (pos + l) (len - l) w
+
+module Symbol = struct
+  let counter = ref 0
+  let gen_sym () = incr counter; Printf.sprintf "_DREL%i" !counter
+
+  let empty () =
+    { sym_pos = (-1); sym_name = gen_sym(); value = 0l;
+      section = `Num 0; storage = 0; stype = 0; auxn = 0; auxs = Bytes.of_string "";
+      extra_info = `None }
+
+  let intern sec addr =
+    { (empty ()) with section = `Section sec; storage = 3; value = addr }
+
+  let named_intern name sec addr =
+    { (empty ()) with sym_name = name; section = `Section sec; storage = 3; value = addr }
+
+  let label name sec addr =
+    { (empty ()) with sym_name = name; section = `Section sec; storage = 6; value = addr }
+
+  let export name sec addr =
+    { (empty ()) with sym_name = name; value = addr;
+        section = `Section sec; storage = 2 }
+
+  let extern name =
+    { (empty ()) with sym_pos = (-1); sym_name = name;
+        section = `Num 0; storage = 2 }
+
+
+  let get ~bigobj strtbl ic pos =
+    let size, sec_get = if bigobj then (20, int32_) else (18, int16) in
+    let buf = read ic pos size in
+    let auxn = int8 buf (size - 1) in
+    { sym_pos = (-1);
+      sym_name =
+        (if int32_ buf 0 <> 0 then strz buf 0 ~max:8 '\000'
+         else strtbl (int32_ buf 4));
+      value = int32 buf 8;
+      section = `Num (sec_get buf 12);
+      stype = int16 buf (size - 4);
+      storage = int8 buf (size - 2);
+      auxn = auxn;
+      auxs = read ic (pos + size) (size * auxn);
+      extra_info = `None;
+    }
+
+  let is_extern = function
+    | { storage = 2; section = `Num 0; value = 0l } -> true
+    | _ -> false
+
+  let is_export = function
+    | { storage = 2; section = `Section _ } -> true
+    | { storage = 2; section = `Num 0; value = 0l } -> false
+    | { storage = 2; section = `Num 0 } -> true
+    | _ -> false
+
+  let is_defin = function
+    | { storage = 2; section = `Section _ } -> true
+    | { storage = 2; section = `Num 0; value = 0l } -> false
+    | { storage = 2; section = `Num (0 | 0xffff) } -> true
+    | _ -> false
+
+  let dump s =
+    Printf.printf " %s: " s.sym_name;
+    if s.stype <> 0 then Printf.printf "(typ:%i) " s.stype;
+    let sect = match s.section with
+      | `Num 0xffff -> "absolute"
+      | `Num 0xfffe -> "debug"
+      | `Num i -> string_of_int i
+      | `Section s -> Printf.sprintf "%S" s.sec_name in
+    let storage = match s.storage with
+      | 2 -> "extern"
+      | 3 -> "static"
+      | 6 -> "label"
+      | 103 -> "srcfile"
+      | n -> string_of_int n in
+    match s with
+      | { storage = 6 } ->
+          Printf.printf "label %s @ 0x%08lx\n" sect s.value
+      | { storage = 2; section = `Section _ } ->
+          Printf.printf "export %s @ 0x%08lx\n" sect s.value
+      | { storage = 2; section = `Num 0; value = 0l } ->
+          Printf.printf "extern\n"
+      | { storage = 2; section = `Num 0; value = n } ->
+          Printf.printf "common symbol, size %ld\n" n
+      | { storage = 3; value = 0l; auxn = auxn } when auxn > 0 ->
+          Printf.printf "section %s, num %i, select %i\n" sect
+            (int16 s.auxs 12)
+            (int8 s.auxs 14)
+      | { storage = 3 } ->
+          Printf.printf "static %s @ 0x%08lx\n" sect s.value
+      | { storage = 103 } ->
+          Printf.printf "filename %s\n" (strz s.auxs 0 '\000')
+      | { storage = 105 } ->
+          Printf.printf "weak ext\n"
+      | _ ->
+          Printf.printf
+            "value=0x%08lx, sect=%s, storage=%s, aux=%S\n"
+            s.value sect storage (Bytes.to_string s.auxs)
+
+  let put ~bigobj strtbl oc s =
+    let sec_get, sec_put, type_ofs =
+      if bigobj then
+        (int32_, (fun oc i -> emit_int32 oc (Int32.of_int i)), 16)
+      else
+        (int16, emit_int16, 14) in
+    if String.length s.sym_name <= 8
+    then (output_string oc s.sym_name;
+          emit_zero oc (8 - String.length s.sym_name))
+    else (emit_zero oc 4; emit_int32 oc (strtbl s.sym_name));
+    emit_int32 oc s.value;
+    let sec = match s.section with
+      | `Num i -> i
+      | `Section sec when sec.sec_pos <= 0 ->
+          failwith (Printf.sprintf
+                      "Cannot emit section for symbol %s" s.sym_name)
+      | `Section sec -> sec.sec_pos in
+    sec_put oc sec;
+    emit_int16 oc s.stype;
+    emit_int8 oc s.storage;
+    emit_int8 oc s.auxn;
+    match s with
+      | { storage = 105; extra_info = `Alias s' } when s'.sym_pos >= 0 ->
+          (* weak ext *)
+          emit_int32 oc (Int32.of_int s'.sym_pos);
+          output_bytes oc (Bytes.sub s.auxs 4 (Bytes.length s.auxs - 4))
+      | { storage = 3; extra_info = `Section s' } when int8 s.auxs 14 = 5 (* IMAGE_COMDAT_SELECT_ASSOCIATIVE *) ->
+          (* section def *)
+          output_bytes oc (Bytes.sub s.auxs 0 12);
+          sec_put oc s'.sec_pos;
+          output_bytes oc (Bytes.sub s.auxs type_ofs (Bytes.length s.auxs - type_ofs))
+      | { storage = 3; extra_info = `Section s' } ->
+          (* section def *)
+          Printf.eprintf "!!! section symbol not supported (symbol: %s -> section:%s)\n%!" s.sym_name s'.sec_name;
+          Printf.eprintf "length = %i\n" (int32_ s.auxs 0);
+          Printf.eprintf "# reloc = %i\n" (int16 s.auxs 4);
+          Printf.eprintf "# linenum = %i\n" (int16 s.auxs 6);
+          Printf.eprintf "checksum = %i\n" (int32_ s.auxs 8);
+          Printf.eprintf "idx = %i\n" (int16 s.auxs 12);
+          Printf.eprintf "sel = %i\n" (int8 s.auxs 14);
+          assert false
+      | _ ->
+          if s.storage = 105 then assert (sec_get s.auxs 12 = 0);
+          output_bytes oc s.auxs
+end
+
+module Reloc = struct
+  let abs machine sec addr sym =
+    let rtype =
+      match machine with
+      | `x86 -> 0x06
+      | `x64 -> 0x01
+    in
+    sec.relocs <- { addr = addr; symbol = sym; rtype = rtype } :: sec.relocs
+
+  let rel32 machine sec addr sym =
+    let rtype =
+      match machine with
+      | `x86 -> 0x14
+      | `x64 -> 0x04
+    in
+    sec.relocs <- { addr = addr; symbol = sym; rtype = rtype } :: sec.relocs
+
+  let get symtbl va ic base =
+    let buf = read ic base 10 in
+    { addr = Int32.sub (int32 buf 00) va;
+      symbol = (try match symtbl.(int32_ buf 4) with Some s -> s
+                  | None -> assert false
+                with _exn -> assert false);
+      rtype = int16 buf 8
+    }
+
+  let dump x =
+    Printf.printf " Reloc %ld -> %s, type 0x%04x\n"
+      x.addr x.symbol.sym_name x.rtype
+
+  let put oc x =
+    emit_int32 oc x.addr;
+    if x.symbol.sym_pos < 0 then
+      failwith (Printf.sprintf
+                  "Cannot emit relocation for symbol %s\n"
+                  x.symbol.sym_name);
+    emit_int32 oc (Int32.of_int x.symbol.sym_pos);
+    emit_int16 oc x.rtype
+end
+
+module Section = struct
+  let create name flags = {
+    sec_pos = (-1); sec_name = name; data = `String (Bytes.of_string ""); relocs = [];
+    vaddress = 0l; vsize = 0l; sec_opts = flags;
+  }
+
+  let nreloc_ovfl = 0x01000000l
+
+  let get filebase strtbl symtbl ic base =
+    let buf = read ic base 40 in
+    let size = int32_ buf 16 in
+    let name =
+      if Bytes.get buf 0 = '/'
+      then strtbl (int_of_string (strz buf 1 ~max:7 '\000'))
+      else strz buf 0 ~max:8 '\000'
+    in
+    let va = int32 buf 12 in
+
+    let nrelocs = int16 buf 32 in
+    let more_relocs = int32 buf 36 &&& nreloc_ovfl <> 0l in
+    let base_relocs = filebase + int32_ buf 24 in
+    let base_relocs, nrelocs =
+      if more_relocs then begin
+        let buf_first_reloc = read ic base_relocs 4 in
+        let n = int32_ buf_first_reloc 0 in
+        base_relocs + 10, n - 1
+      end else
+        base_relocs, nrelocs
+    in
+
+    let relocs =
+      let r = ref [] in
+      for i = 0 to nrelocs - 1 do
+        r := Reloc.get symtbl va ic (base_relocs + 10 * i) :: !r
+      done;
+      !r
+    in
+
+    let data =
+      if name = ".sxdata" then
+        let s = read ic (filebase + int32_ buf 20) size in
+        `Sxdata
+          (Array.init (size /4)
+             (fun i -> match symtbl.(int32_ s (i * 4)) with None -> assert false | Some s -> s))
+      else if int32_ buf 20 = 0 then `Uninit size
+      else `String (read ic (filebase + int32_ buf 20) size)
+(*        `Lazy (ic, filebase + int32_ buf 20, size) *)
+    in
+
+    { sec_pos = (-1);
+      sec_name = name;
+      vsize = int32 buf 8;
+      vaddress = 0l;
+      data = data;
+      relocs = relocs;
+      sec_opts = int32 buf 36
+    }
+
+  let dump x =
+    Printf.printf "Section %s (0x%08lx: %s)\n"
+      x.sec_name
+      x.sec_opts
+      (flags x.sec_opts);
+    List.iter Reloc.dump x.relocs
+
+  let size s =
+    match s.data with
+    | `String s -> Bytes.length s
+    | `Lazy (_,_,len) -> len
+    | `Uninit len -> len
+    | `Buf bufs -> List.fold_left (fun s b -> s + Buf.length b) 0 bufs
+    | `Sxdata syms -> Array.length syms * 4
+
+  let put strtbl oc x =
+    let name =
+      if String.length x.sec_name <= 8
+      then x.sec_name
+      else Printf.sprintf "/%ld" (strtbl x.sec_name)
+    in
+    output_string oc name; emit_zero oc (8 - String.length name);
+    emit_int32 oc x.vsize;
+(*    assert(x.vaddress = 0l); *)
+    emit_int32 oc x.vaddress;
+    emit_int32 oc (Int32.of_int (size x));
+    let send_data = match x.data with
+      | `String s ->
+          delayed_ptr oc (fun () -> output_bytes oc s)
+      | `Lazy (ic,pos,len) ->
+          delayed_ptr oc (fun () -> copy_data ic pos oc len)
+      | `Uninit _len ->
+          emit_int32 oc 0l; (fun () -> ())
+      | `Buf bufs ->
+          delayed_ptr oc (fun () -> List.iter (Buf.dump oc) bufs)
+      | `Sxdata syms ->
+          delayed_ptr oc
+            (fun () ->
+              Array.iter (fun sym -> assert(sym.sym_pos >= 0); emit_int32 oc (Int32.of_int sym.sym_pos)) syms
+            )
+    in
+
+    let nrelocs = List.length x.relocs in
+    let many_relocs = nrelocs > 0xffff in
+
+    let send_reloc =
+      if x.relocs = [] then (emit_int32 oc 0l; fun () -> ())
+      else delayed_ptr oc
+          (fun () ->
+            if many_relocs then begin
+              emit_int32 oc (Int32.of_int (nrelocs + 1));
+              (* +1 because this slot counts as well! *)
+              emit_int32 oc 0l;
+              emit_int16 oc 0
+            end;
+            List.iter (Reloc.put oc) x.relocs
+          )
+    in
+
+    emit_int32 oc 0l;
+    if many_relocs then emit_int16 oc 0xffff
+    else emit_int16 oc nrelocs;
+    emit_int16 oc 0;
+    let sec_opts = if many_relocs then x.sec_opts ||| nreloc_ovfl else x.sec_opts &&& Int32.lognot nreloc_ovfl in
+    emit_int32 oc sec_opts;
+
+    send_data, send_reloc
+end
+
+module FileHeader = struct
+  type header = {
+    hdrsize : int;
+    machine : int;
+    seccount : int;
+    date: int32;
+    symtable : int;
+    symcount : int;
+    opthdr : int;
+    opts : int;
+
+    symsize : int;
+    bigobj: bool;
+  }
+
+  let bigobj_classid =
+    "\xC7\xA1\xBA\xD1\xEE\xBA\xA9\x4B\xAF\x20\xFA\xF6\x6A\xA4\xDC\xB8"
+
+  let get_image_file_header ic ofs =
+    let hdrsize = 20 in
+    let buf = read ic ofs hdrsize in
+    let machine = int16 buf 0 in
+    let seccount = int16 buf 2 in
+    let date = int32 buf 4 in
+    let symtable = int32_ buf 8 in
+    let symcount = int32_ buf 12 in
+    let opthdr = int16 buf 16 in
+    let opts = int16 buf 18 in
+    let symsize = 18 in
+    let bigobj = false in
+    { hdrsize = hdrsize; machine = machine; seccount = seccount; date = date;
+      symtable = symtable; symcount = symcount; opthdr = opthdr; opts = opts;
+      symsize = symsize; bigobj = bigobj }
+
+  let get_header_bigobj ic ofs =
+    let hdrsize = 56 in
+    let buf = read ic ofs hdrsize in
+    let machine = int16 buf 6 in
+    let date = int32 buf 8 in
+    let opts = int32_ buf 32 in
+    let seccount = int32_ buf 44 in
+    let symtable = int32_ buf 48 in
+    let symcount = int32_ buf 52 in
+    let symsize = 20 in
+    let opthdr = 0 in
+    let bigobj = true in
+    { hdrsize = hdrsize; machine = machine; seccount = seccount; date = date;
+      symtable = symtable; symcount = symcount; opthdr = opthdr; opts = opts;
+      symsize = symsize; bigobj = bigobj }
+
+  let get ic ofs =
+    let buf = read ic ofs 6 in
+    let sig1 = int16 buf 0 in
+    let sig2 = int16 buf 2 in
+    if sig1 = 0 && sig2 = 0xFFFF then
+      let version = int16 buf 4 in
+      if version = 0 then
+        `IMPORT_OBJECT_HEADER (* names from winnt.h *)
+      else if version = 1 then
+        `ANON_OBJECT_HEADER
+      else (* version >= 2 *)
+        `ANON_OBJECT_HEADER_BIGOBJ (get_header_bigobj ic ofs)
+    else
+      `IMAGE_FILE_HEADER (get_image_file_header ic ofs)
+end
+
+module Coff = struct
+  let add_section x sect =
+    x.sections <- sect :: x.sections
+  let add_symbol x sym =
+    x.symbols <- sym :: x.symbols
+
+  let create machine =
+    let machine =
+      match machine with
+      | `x64 -> 0x8664
+      | `x86 -> 0x14c
+    in
+    { bigobj = false;
+      obj_name = "generated";
+      machine = machine; date = 0x4603de0el;
+      sections = []; symbols = []; opts = 0 }
+
+  let parse_directives s =
+    let rec find_end i =
+      if i = 0 || s.[i - 1] <> '\000' then i
+      else find_end (i - 1)
+    in
+    let l = find_end (String.length s) in
+    let rec aux0 i = if i = l then [] else match s.[i] with
+      | ' ' -> aux0 (i+1)
+      | '-' | '/' -> aux1 (i+1) (i+1)
+      | _ -> raise Exit
+    and aux1 i0 i = if i = l then (String.sub s i0 (i - i0), [])::[]
+    else match s.[i] with
+      | 'a'..'z' | 'A'..'Z' -> aux1 i0 (i+1)
+      | ' ' -> (String.sub s i0 (i - i0), []) :: aux0 (i+1)
+      | ':' -> aux2 (String.sub s i0 (i - i0)) [] (i+1)
+      | _   -> raise Exit
+    and aux2 cmd args i = match s.[i] with
+      | '"' -> aux3 cmd args (i+1) (i+1)
+      | _   -> aux4 cmd args i i
+    and aux3 cmd args i0 i = match s.[i] with
+      | '"' -> aux5 cmd (String.sub s i0 (i - i0) :: args) (i+1)
+      | _   -> aux3 cmd args i0 (i+1)
+    and aux4 cmd args i0 i =
+      if i = l then (cmd, String.sub s i0 (i - i0) :: args)::[]
+      else match s.[i] with
+        | ' ' -> (cmd, String.sub s i0 (i - i0) :: args) :: aux0 (i+1)
+        | ',' -> aux2 cmd (String.sub s i0 (i - i0) :: args) (i+1)
+        | _   -> aux4 cmd args i0 (i+1)
+    and aux5 cmd args i =
+      if i = l then (cmd, args) :: []
+      else match s.[i] with
+      | ' ' -> (cmd,args) :: aux0 (i+1)
+      | ',' -> aux2 cmd args (i+1)
+      | _   -> raise Exit
+    in
+    try List.map (fun (cmd,args) -> (cmd,List.rev args)) (aux0 0)
+    with _ ->
+      failwith (Printf.sprintf "Cannot parse directive: %s\n" s)
+
+  let directives obj =
+    try
+      let sec = List.find (fun s -> s.sec_name = ".drectve") obj.sections in
+      match force_section_data sec with
+        | `String s -> parse_directives (Bytes.to_string s)
+        | `Uninit _ | `Sxdata _ -> []
+        | `Lazy _ | `Buf _ -> assert false
+    with Not_found -> []
+
+  let get ic ofs base h name =
+    let symtable = base + h.FileHeader.symtable in
+
+    (* the string table *)
+    let strtbl =
+      let pos = symtable + h.FileHeader.symsize * h.FileHeader.symcount in
+      if pos = 0 then fun _ -> assert false
+      else
+        let len = int32_ (read ic pos 4) 0 in
+        let data = read ic pos len in
+        fun i -> strz data i '\000'
+    in
+
+
+    (* the symbol table *)
+    let symbols,symtbl =
+      let tbl = Array.make h.FileHeader.symcount None in
+      let rec fill accu i =
+        if i = h.FileHeader.symcount then List.rev accu
+        else let s = Symbol.get h.FileHeader.bigobj strtbl ic (symtable + h.FileHeader.symsize * i) in
+        (try tbl.(i) <- Some s
+         with Invalid_argument _ -> assert false);
+        fill (s :: accu) (i + 1 + s.auxn) in
+      fill [] 0, tbl
+    in
+
+    (* the sections *)
+    let sectable = ofs + h.FileHeader.hdrsize + h.FileHeader.opthdr in
+    let sections =
+      Array.init h.FileHeader.seccount
+        (fun i -> Section.get base strtbl symtbl ic (sectable + 40 * i))
+    in
+
+    (* remove .bf/.ef/.lf symbols *)
+    let symbols =
+      List.filter (function { storage = 101 } -> false | _ -> true)
+        symbols in
+    List.iter
+      (fun s ->
+         (match s with
+            | { storage = 105; auxn = 1 } ->
+                (* weak ext *)
+                (try match symtbl.(Int32.to_int (int32 s.auxs 0)) with
+                   | Some s' -> s.extra_info <- `Alias s'
+                   | None -> assert false
+                 with Invalid_argument _ -> assert false);
+            | { storage = 3; stype = 0; auxn = auxn } when auxn > 0 ->
+                (* section def *)
+                let num = int16 s.auxs 12 in
+                let sel = int8 s.auxs 14 in
+                if sel = 5 && num > 0 then
+                  (try s.extra_info <- `Section sections.(num - 1)
+                   with Invalid_argument _ ->
+                     Printf.eprintf "** section %i / %i (%s)\n" num
+                       (Array.length sections) s.sym_name;
+                     assert false);
+            | { storage = 103 }
+            | { auxn = 0 } -> ()
+            | { storage = (2|3); stype = 0x20; auxn = 1; auxs = auxs } ->
+                (* Remove extra information for function symbols *)
+                s.auxs <- Bytes.make (Bytes.length auxs) '\000'
+            | _ ->
+                Symbol.dump s;
+                Printf.printf "aux=%S\n%!" (Bytes.to_string s.auxs);
+                assert false);
+         (match s.section with
+            | `Num i when i > 0 && i <= Array.length sections ->
+                assert (i <= Array.length sections);
+                (try s.section <- `Section sections.(i - 1)
+                 with Invalid_argument _ -> assert false);
+            | _ -> ()))
+      symbols;
+
+    { bigobj = h.FileHeader.bigobj;
+      obj_name = name;
+      machine = h.FileHeader.machine;
+      sections = Array.to_list sections;
+      date = h.FileHeader.date;
+      symbols = symbols;
+      opts = h.FileHeader.opts;
+    }
+
+  let aliases x =
+    let a = ref [] in
+    List.iter
+      (fun s ->
+         match s.extra_info with
+           | `Alias s' -> a := (s.sym_name,s'.sym_name) :: !a
+           | _ -> ()
+      )
+      x.symbols;
+    !a
+
+
+
+  let dump x =
+    Printf.printf "machine: 0x%x\n" x.machine;
+    Printf.printf "date:    0x%lx\n" x.date;
+    Printf.printf "opts:    0x%x\n" x.opts;
+    List.iter Symbol.dump x.symbols;
+    List.iter Section.dump x.sections;
+    flush stdout
+
+  let put oc x =
+    let () =
+      let no = ref 0 in
+      List.iter
+        (fun s -> incr no; assert(s.sec_pos < 0); s.sec_pos <- !no)
+        x.sections
+    in
+
+    if x.bigobj then begin
+      emit_int16 oc 0; (* Sig1 *)
+      emit_int16 oc 0xffff; (* Sig2 *)
+      emit_int16 oc 2; (* Version *)
+      emit_int16 oc x.machine;
+      emit_int32 oc x.date;
+      output_string oc FileHeader.bigobj_classid;
+      emit_int32 oc 0l;
+      emit_int32 oc (Int32.of_int x.opts);
+      emit_int32 oc 0l;
+      emit_int32 oc 0l;
+      emit_int32 oc (Int32.of_int (List.length x.sections));
+    end
+    else begin
+      emit_int16 oc x.machine;
+      emit_int16 oc (List.length x.sections);
+      emit_int32 oc x.date;
+    end;
+
+    let strbuf = Buffer.create 1024 in
+    let strtbl s =
+      let pos = Buffer.length strbuf in
+      Buffer.add_string strbuf s;
+      Buffer.add_char strbuf '\000';
+      Int32.of_int (4 + pos)
+    in
+
+    let patch_sym =
+      delayed_ptr oc
+        (fun () -> List.iter (Symbol.put ~bigobj:x.bigobj strtbl oc) x.symbols)
+    in
+    let nbsym =
+      let no = ref 0 in
+      List.iter
+        (fun s ->
+           assert(s.sym_pos < 0);
+           s.sym_pos <- !no;
+           no := !no + 1 + s.auxn
+        )
+        x.symbols;
+      !no
+    in
+    emit_int32 oc (Int32.of_int nbsym);
+    if not x.bigobj then begin
+      emit_int16 oc 0;
+      emit_int16 oc x.opts;
+    end;
+
+    let sects =
+      List.map (Section.put strtbl oc) x.sections in
+    List.iter
+      (fun (data,relocs) -> data (); relocs ())
+      sects;
+
+    patch_sym ();
+
+    emit_int32 oc (Int32.of_int (Buffer.length strbuf + 4));
+    Buffer.output_buffer oc strbuf;
+
+    List.iter (fun s -> s.sym_pos <- 0) x.symbols;
+    List.iter (fun s -> s.sec_pos <- 0) x.sections;
+    ()
+end
+
+module Import = struct
+  let read ic pos size =
+    let buf = read ic pos size in
+    let w = int16 buf 18 in
+    let name = strz buf 20 '\000' in
+(*    Printf.printf "Import header. Version = %i\n" (int16 buf 4);
+    Printf.printf " machine     = 0x%x\n" (int16 buf 6);
+    Printf.printf " time stamp  = 0x%lx\n" (int32 buf 8);
+    Printf.printf " size data   = %ld\n" (int32 buf 12);
+    Printf.printf " ord/hint    = %i\n" (int16 buf 16);
+    Printf.printf " type        = %i\n" (w land 0b11);
+    Printf.printf " name type   = %i\n" ((w land 0b11100) lsr 2);
+    Printf.printf " symbol      = %s\n" name;
+    Printf.printf " DLL         = %s\n"
+      (strz buf (21 + String.length name) '\000'); *)
+    name, w
+
+end
+
+module Lib = struct
+  let magic_lib = "!<arch>\n"
+
+  let read_lib ic libname =
+    let strtbl = ref (Bytes.of_string "") in
+    let imports = ref [] and objects = ref [] in
+    let obj size name =
+(*      Printf.printf "-> %s (size %i)\n" name size;  *)
+      let pos = pos_in ic in
+      match FileHeader.get ic pos with
+      | `IMPORT_OBJECT_HEADER ->
+        if size > 18 then
+          imports := Import.read ic pos size :: !imports
+      | `ANON_OBJECT_HEADER_BIGOBJ h
+      | `IMAGE_FILE_HEADER h ->
+        objects := (name,
+                    Coff.get ic pos pos h
+                      (Printf.sprintf "%s(%s)" libname name)) :: !objects
+      | `ANON_OBJECT_HEADER ->
+        () (* ignore *)
+    in
+    let rec read_member () =
+      let buf = read ic (pos_in ic) 60 in
+      let base = pos_in ic in
+      let size = int_of_string (strz (Bytes.sub buf 48 10) 0 ' ') in
+      let name = strz (Bytes.sub buf 0 16) 0 ' ' in
+      begin match name with
+        | "/" | "" -> ()
+        | "//" -> strtbl := read ic (pos_in ic) size
+        | s when s.[0] = '/' ->
+            let ofs =
+              try Scanf.sscanf s "/%u%!" (fun x -> x)
+              with Scanf.Scan_failure _
+                 | Failure _
+                 | End_of_file -> -1
+            in
+              (* Ignore special sections which we don't know about *)
+              if ofs >= 0 then
+                obj size (strz !strtbl ofs '\000')
+        | s when s.[String.length s - 1] = '/' ->
+            let s = String.sub s 0 (String.length s - 1) in
+            obj size s
+        | s ->
+            Printf.ksprintf failwith "Cannot parse archive member %s" s
+      end;
+      seek_in ic (base + size + size mod 2);
+      read_member ()
+    in
+    (try read_member () with End_of_file -> ());
+    !objects,!imports
+
+  let is_lib ic =
+    in_channel_length ic >= String.length magic_lib
+    && read_str ic 0 (String.length magic_lib) = magic_lib
+
+  let obj_ofs ic =
+    try
+      let b = read ic 0x3c 4 in
+      let ofs = int32_ b 0 in
+      if read_str ic ofs 4 = "PE\000\000" then ofs + 4
+      else 0
+    with _exn ->
+      0
+
+  let is_dll filename =
+    let ic = open_in_bin filename in
+    let ofs = obj_ofs ic in
+    close_in ic;
+    ofs > 0
+
+  let read filename =
+    let ic = open_in_bin filename in
+    try
+(*      let t0 = Unix.gettimeofday () in
+      Printf.printf "Reading %s...%!" filename; *)
+      let r =
+        if is_lib ic then `Lib (read_lib ic filename)
+        else
+          let ofs = obj_ofs ic in
+          let h = match FileHeader.get ic ofs with
+          | `ANON_OBJECT_HEADER_BIGOBJ h
+          | `IMAGE_FILE_HEADER h -> h
+          | `IMPORT_OBJECT_HEADER
+          | `ANON_OBJECT_HEADER -> assert false in
+          `Obj (Coff.get ic ofs 0 h filename) in
+(*      close_in ic; *)  (* do not close: cf `Lazy *)
+(*      let t1 = Unix.gettimeofday () in
+      Printf.printf "  Done  (%f ms)\n%!" (t1 -. t0);  *)
+      r
+    with exn ->
+      close_in ic;
+      raise exn
+
+  let read filename =
+    try
+      read filename
+    with exn ->
+      failwith
+        (Printf.sprintf "Error while reading %s: %s"
+           filename (Printexc.to_string exn))
+
+end
+
+
+module Stacksize = struct
+  let set_stack_reserve filename reserve =
+    let filename =
+      if not (Sys.file_exists filename) && (Sys.file_exists (filename ^ ".exe")) then filename ^ ".exe"
+      else filename
+    in
+    let ic = open_in_bin filename in
+    let hdr_offset = int16 (read ic 0x3c 2) 0 in
+    let pe_signature = read_str ic hdr_offset 4 in
+    assert(pe_signature = "PE\000\000");
+    let coff_hdr = read ic 0 20 in
+    let opthdr_size = int16 coff_hdr 16 in
+    let opthdr = read ic (hdr_offset + 24) opthdr_size in
+    let machine =
+      match int16 opthdr 0 with
+      | 0x10b -> `x86
+      | 0x20b -> `x64
+      | magic -> Printf.ksprintf failwith "Cannot determine image target (magic = %x)." magic
+    in
+    let reserve_offset = hdr_offset + 24 + 72 in
+(*    Printf.printf "current stack reserve %ld\n%!" (int32 opthdr 72); *)
+    close_in ic;
+
+    let oc = open_out_gen [Open_wronly; Open_binary] 0x777 filename in
+    seek_out oc reserve_offset;
+    emit_int32 oc reserve;
+    if machine = `x64 then emit_int32 oc 0l;
+    close_out oc
+end
--- ./flexdll/create_dll.ml
+++ ./flexdll/create_dll.ml
@@ -0,0 +1,419 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+(* Create a DLL from a set of "closed" COFF files (no imported symbol). *)
+
+include (struct
+open Coff
+
+let (&&&) = Int32.logand
+let (|||) = Int32.logor
+let (<<<) = Int32.shift_left
+
+let read_int32 s i =
+  Int32.of_int (Char.code (Bytes.get s i)) |||
+  (Int32.of_int (Char.code (Bytes.get s (i+1))) <<< 8) |||
+  (Int32.of_int (Char.code (Bytes.get s (i+2))) <<< 16) |||
+  (Int32.of_int (Char.code (Bytes.get s (i+3))) <<< 24)
+
+let align x n =
+  let k = Int32.rem x n in
+  if k = 0l then x
+  else Int32.add x (Int32.sub n k)
+
+let discard_section s =
+  let opts = s.sec_opts in
+  opts &&&
+  (0x00000200l (* Info section (.drectve) *)
+ ||| 0x00000800l (* Remove *)
+ ||| 0x02000000l) <> 0l (* Discardable *)
+
+let sect_data s =
+  match force_section_data s with
+  | `String data -> data
+  | `Buf _ -> assert false
+  | `Lazy _ -> assert false
+  | `Sxdata _ -> assert false
+  | `Uninit 0 -> Bytes.of_string ""
+  | `Uninit size ->
+      failwith
+        (Printf.sprintf
+           "uninitialized section %s (size %d): not supported"
+           s.sec_name size
+        )
+
+let split_relocs page_size relocs =
+  let relocs = Array.of_list relocs in
+  Array.sort (fun (i, _) (j, _) -> compare i j) relocs;
+  let blocks = ref [] and current_block = ref (ref []) and current_base = ref (-1l) in
+  Array.iter
+    (fun (rva, k) ->
+      let base = Int32.mul (Int32.div rva page_size) page_size in
+      let ofs = Int32.to_int (Int32.sub rva base) in
+      if base = !current_base then (!current_block) := (ofs, k) :: !(!current_block)
+      else begin
+        current_base := base;
+        current_block := ref [(ofs, k)];
+        blocks := (base, !current_block) :: !blocks
+      end
+    )
+    relocs;
+  List.rev_map (fun (base, relocs) -> (base, List.rev !relocs)) !blocks
+
+
+type sec_info = {
+    sec_info_obj: coff; (* original object *)
+    mutable sec_info_sec: section; (* target section in the image *)
+    mutable sec_info_ofs: int32; (* offset within the target image *)
+    sec_info_vaddress: int32 Lazy.t;
+  }
+
+let create_dll oc objs =
+  let image_base = 0x10000l in
+  let page_size = 0x1000l in
+  let dllname = "foo.dll" in
+
+  (* msdos stub *)
+  output_string oc "MZ";
+  for _i = 3 to 0x3c do output_byte oc 0 done;
+  emit_int32 oc 0xe8l; (* file offset of COFF file header, just here *)
+  for _i = 0x40 to 0xe7 do output_byte oc 0 done;
+
+  let sections = Hashtbl.create 8 in
+  let sec_id = ref 0 in
+  let sec_info = Hashtbl.create 8 in
+  let sym_id = ref 0 in
+  let globals = Hashtbl.create 8 in
+  let locals = Hashtbl.create 8 in
+  let commons = Hashtbl.create 8 in
+  let relocs = ref [] in
+
+  List.iter
+    (fun obj ->
+      List.iter
+        (fun s ->
+          (* todo: cut the section name at 8 chars, remove the part of $ *)
+          if discard_section s then ()
+          else let (l, sect) =
+            try Hashtbl.find sections s.sec_name
+            with Not_found ->
+              let r =
+                ref [],
+                Section.create s.sec_name
+                  (s.sec_opts
+                     &&& (0x00000020l
+                        ||| 0x00000040l
+                        ||| 0x00000080l
+                        ||| 0x10000000l
+                        ||| 0x20000000l
+                        ||| 0x40000000l
+                        ||| 0x80000000l))
+              in
+              Hashtbl.replace sections s.sec_name r;
+              r
+          in
+          l := s :: !l;
+          s.sec_pos <- !sec_id;
+          incr sec_id;
+          let rec info =
+            {
+             sec_info_obj = obj;
+             sec_info_sec = sect;
+             sec_info_ofs = 0l;
+             sec_info_vaddress = lazy (Int32.add info.sec_info_ofs sect.vaddress)
+           }
+          in
+          Hashtbl.replace sec_info s.sec_pos info
+        )
+        obj.sections;
+
+      List.iter
+        (function
+          | {sym_name=name; value=ofs; storage=storage; section = `Section s} as sym when s.sec_pos >= 0 ->
+              let info = Hashtbl.find sec_info s.sec_pos in
+              let rva = lazy (Int32.add ofs (Lazy.force info.sec_info_vaddress)) in
+              if storage = 2
+              then
+                if Hashtbl.mem globals name
+                then failwith ("Multiply defined symbol: " ^ name)
+                else Hashtbl.replace globals name rva
+              else begin
+                sym.sym_pos <- !sym_id;
+                incr sym_id;
+                Hashtbl.replace locals sym.sym_pos rva
+              end
+          | {sym_name=name; storage=2; section=`Num 0; value=size } ->
+              let oldsize =
+                try Hashtbl.find commons name
+                with Not_found -> 0l
+              in
+              Hashtbl.replace commons name (max size oldsize)
+          | _ -> ()
+        )
+        obj.symbols;
+    )
+    objs;
+
+  let rva_of_global s =
+    try Hashtbl.find globals s
+    with Not_found -> failwith ("Cannot find global symbol " ^ s)
+  in
+  let rva_of_local s =
+    try Hashtbl.find locals s
+    with Not_found -> assert false
+  in
+
+  let sects = ref [] in
+  (* Put image sections at their target rva *)
+  let va = ref 0x1000l in
+  let put_sect s =
+    s.vsize <- Int32.of_int (Section.size s);
+    s.vaddress <- !va;
+    va := align (Int32.add !va s.vsize) 0x1000l;
+    sects := s :: !sects
+  in
+
+  (* create the uninitialized section data *)
+  let () =
+    let bss = Section.create ".bss" 0xC0000080l in
+    let total = ref 0l in
+    Hashtbl.iter
+      (fun name size ->
+        if not (Hashtbl.mem globals name) && size > 0l
+        then
+          let pos = !total in
+          total := Int32.add !total size;
+          let rva = lazy (Int32.add pos bss.vaddress) in
+          Hashtbl.replace globals name rva
+      )
+      commons;
+    bss.data <- `Uninit (Int32.to_int !total);
+    if !total <> 0l then put_sect bss
+  in
+
+  let treat_sect (l, sect) =
+    let sect_len = ref 0 in
+    let mk_sect s =
+      let buf = Buf.create () in
+      let info = Hashtbl.find sec_info s.sec_pos in
+      let sec_ofs = !sect_len in
+      info.sec_info_ofs <- Int32.of_int sec_ofs;
+      let sdata = sect_data s in
+      let slen = Bytes.length sdata in
+
+      let pad =
+        if slen mod 16 = 0 then 0
+        else 16 - slen mod 16
+      in
+      sect_len := !sect_len + Bytes.length sdata + pad;
+      Buf.bytes buf sdata;
+      if pad > 0 then
+        Buf.bytes buf (Bytes.make pad '\000');
+
+      let mk_reloc r =
+        (* rva of the target symbol *)
+        let sym = r.symbol in
+        let rva =
+          if Symbol.is_extern sym || Symbol.is_export sym then rva_of_global sym.sym_name
+          else if sym.sym_pos >= 0 then rva_of_local sym.sym_pos
+          else begin
+            Symbol.dump sym;
+            failwith (Printf.sprintf "Cannot resolve symbol %s\n" sym.sym_name)
+          end
+        in
+
+        (* rva of the relocation *)
+        let rel_rva = lazy (Int32.add r.addr (Lazy.force info.sec_info_vaddress)) in
+
+        let pos = Int32.to_int r.addr in
+        let initial = read_int32 sdata pos in
+        match !Cmdline.machine, r.rtype with
+        | `x86, 0x06 (* IMAGE_REL_I386_DIR32 *)
+        | `x64, 0x02 (* IMAGE_REL_AMD64_ADDR32 *) ->
+            (* 32-bit VA *)
+            relocs := (rel_rva, `R32) :: !relocs;
+            Buf.patch_lazy_int32 buf pos (lazy (Int32.add (Int32.add initial (Lazy.force rva)) image_base))
+
+        | `x64, 0x01 (* IMAGE_REL_AMD64_ADDR64 *) ->
+            (* 64-bit VA *)
+            assert(read_int32 sdata (pos + 4) = 0l);
+            relocs := (rel_rva, `R64) :: !relocs;
+            Buf.patch_lazy_int32 buf pos (lazy (Int32.add (Int32.add initial (Lazy.force rva)) image_base))
+
+        | `x86, 0x14 (* IMAGE_REL_I386_REL32 *)
+        | `x64, 0x04 (* IMAGE_REL_AMD64_REL32 *) ->
+            Buf.patch_lazy_int32 buf pos (lazy (Int32.sub (Int32.add initial (Lazy.force rva)) (Int32.add (Lazy.force rel_rva) 4l)))
+        | _, k ->
+            Printf.ksprintf failwith "Unsupport relocation kind %04x for %s"
+              k r.symbol.sym_name
+      in
+      List.iter mk_reloc s.relocs;
+      buf
+    in
+    let bufs = List.map mk_sect !l in
+    sect.data <- `Buf bufs;
+    put_sect sect
+  in
+
+  Hashtbl.iter
+    (fun _name x -> treat_sect x)
+    sections;
+
+  (* create the export table *)
+  let edata =
+    let edata = Section.create ".dllexp" 0x40000040l in
+    let b = Buf.create () in
+    edata.data <- `Buf [b];
+    let vaddress = lazy edata.vaddress in
+
+    let export_symbols = ["symtbl";"reloctbl"] in
+    let export_symbols = List.sort compare export_symbols in
+    Buf.int32 b 0l; (* flags *)
+    Buf.int32 b 0l; (* timestamp *)
+    Buf.int32 b 0l; (* version *)
+    let dllname_offset = Buf.future_int32 b vaddress in (* name rva *)
+    Buf.int32 b 1l; (* ordinal base *)
+    Buf.int32 b (Int32.of_int (List.length export_symbols)); (* addr table entries *)
+    Buf.int32 b (Int32.of_int (List.length export_symbols)); (* number of name pointers *)
+    let exp_tbl = Buf.future_int32 b vaddress in (* export address table rva *)
+    let name_ptr_tbl = Buf.future_int32 b vaddress in (* name pointer rva *)
+    let ord_ptr_tbl = Buf.future_int32 b vaddress in (* ordinal table pointer rva *)
+    Buf.set_future b dllname_offset;
+    Buf.string b dllname;
+    Buf.int8 b 0;
+    Buf.set_future b exp_tbl;
+    List.iter (fun s -> Buf.lazy_int32 b (rva_of_global (Cmdline.usym s)))
+      export_symbols;
+    Buf.set_future b name_ptr_tbl;
+    let export_symbols_ofs =
+      List.map (fun _ -> Buf.future_int32 b vaddress) export_symbols
+    in
+    Buf.set_future b ord_ptr_tbl;
+    for i = 0 to List.length export_symbols - 1 do
+      Buf.int16 b i
+    done;
+    List.iter2
+      (fun s f ->
+        Buf.set_future b f;
+        Buf.string b s;
+        Buf.int8 b 0
+      )
+      export_symbols
+      export_symbols_ofs;
+    put_sect edata;
+    edata
+  in
+
+  (* create the reloc table *)
+  let rdata =
+    let rdata = Section.create ".reloc" 0x40000040l in
+    let b = Buf.create () in
+    rdata.data <- `Buf [b];
+
+    (* careful with list functions: the list of relocs can be very long *)
+    let relocs = List.rev_map (fun (rva, k) -> (Lazy.force rva, k)) !relocs in
+    let relocs = split_relocs page_size relocs in
+    List.iter
+      (fun (base, relocs) ->
+        let n = List.length relocs in
+        let size = 8 + 2 * n in
+        let size = if n mod 2 = 1 then size + 2 else size in
+        Buf.int32 b base;
+        Buf.int32 b (Int32.of_int size);
+        List.iter
+          (fun (ofs, k) ->
+             let k =
+               match k with
+               | `R32 -> 0x3000 (* IMAGE_REL_BASED_HIGHLOW *)
+               | `R64 -> 0xA000 (* IMAGE_REL_BASED_DIR64 *)
+             in
+             Buf.int16 b (ofs lor k)
+          )
+          relocs;
+        if n mod 2 = 1 then Buf.int16 b 0
+      )
+      relocs;
+    put_sect rdata;
+    rdata
+  in
+
+  output_string oc "PE\000\000";
+  (* coff header *)
+  let machine = !Cmdline.machine in
+  let disp_mach ~x86 ~x64 =
+    match machine with `x86 -> x86 | `x64 -> x64
+  in
+  let emit_int32_64 x =
+    emit_int32 oc x;
+    if machine = `x64 then emit_int32 oc 0l
+  in
+  emit_int16 oc (disp_mach ~x86:0x14c ~x64:0x8664);
+  emit_int16 oc (List.length !sects); (* number of sections *)
+  emit_int32 oc 0l; (* date *)
+  emit_int32 oc 0l; (* ptr to symbol table *)
+  emit_int32 oc 0l; (* number of symbols *)
+  emit_int16 oc ((disp_mach ~x86:28 ~x64:24) + (disp_mach ~x86:68 ~x64:88) + 8 * 16); (* size of optional headers *)
+  emit_int16 oc
+    (disp_mach
+       ~x86:0x2102 (* flags: exec, 32-bit, dll *)
+       ~x64:0x2022 (* flags: exec, large address aware(?), dll *)
+    );
+
+  (* optional header *)
+  (*   standard fields *)
+  emit_int16 oc (disp_mach ~x86:0x10b ~x64:0x20b); (* magic: pe32/pe32+ *)
+  emit_int16 oc 8; (* linker version *)
+  emit_int32 oc 0l; (* size of code *)
+  emit_int32 oc 0l; (* size of initialized data *)
+  emit_int32 oc 0l; (* size of uninitialized data *)
+  emit_int32 oc 0l; (* entry point *)
+  emit_int32 oc 0x1000l; (* base of code *)
+  if machine = `x86 then emit_int32 oc 0x1000l; (* base of data *)
+  (*   windows-specific fields *)
+  emit_int32_64 image_base; (* image base *)
+  emit_int32 oc 0x1000l; (* section alignment *)
+  emit_int32 oc 0x200l; (* file alignment *)
+  emit_int32 oc 0x04l; (* OS version *)
+  emit_int32 oc 0l; (* image version *)
+  emit_int32 oc 0x04l; (* subsystem version *)
+  emit_int32 oc 0l; (* win32 version *)
+  emit_int32 oc !va; (* size of image *)
+  let size_of_headers = pos_out oc in
+  emit_int32 oc 0l; (* size of headers *)
+  emit_int32 oc 0l; (* checksum *)
+  emit_int16 oc 3; (* subsystem: windows CUI *)
+  emit_int16 oc 0x400; (* characteristics: no EH *)
+  emit_int32_64 0x100000l; (* size of stack reserve *)
+  emit_int32_64 0x1000l; (* size of stack commit *)
+  emit_int32_64 0x100000l; (* size of heap reserve *)
+  emit_int32_64 0x1000l; (* size of heap commit *)
+  emit_int32 oc 0l; (* loader flags *)
+  emit_int32 oc 16l; (* number of directories *)
+
+  (* directories *)
+  for i = 0 to 15 do
+    match i with
+    | 0 -> emit_int32 oc edata.vaddress; emit_int32 oc edata.vsize
+    | 5 -> emit_int32 oc rdata.vaddress; emit_int32 oc rdata.vsize
+    | _ -> emit_int32 oc 0l; emit_int32 oc 0l;
+  done;
+
+  let sects =
+    List.map (Section.put (fun _ -> assert false) oc) (List.rev !sects)
+  in
+  let align_file () =
+    let i = pos_out oc mod 0x200 in
+    if i <> 0 then for _k = i + 1 to 0x200 do output_char oc '\000' done;
+  in
+  align_file ();
+  patch_int32 oc size_of_headers (Int32.of_int (pos_out oc));
+  List.iter (fun (data,_) -> align_file (); data ()) sects
+
+end : sig
+           val create_dll: out_channel -> Coff.coff list -> unit
+end)
--- ./flexdll/default_amd64.manifest
+++ ./flexdll/default_amd64.manifest
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity type="win32" name="Microsoft.VC90.CRT" version="9.0.21022.8" processorArchitecture="amd64" publicKeyToken="1fc8b3b9a1e18e3b"></assemblyIdentity>
+    </dependentAssembly>
+  </dependency>
+</assembly>
--- ./flexdll/default.manifest
+++ ./flexdll/default.manifest
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity type="win32" name="Microsoft.VC90.CRT" version="9.0.21022.8" processorArchitecture="x86" publicKeyToken="1fc8b3b9a1e18e3b"></assemblyIdentity>
+    </dependentAssembly>
+  </dependency>
+</assembly>
--- ./flexdll/flexdll.c
+++ ./flexdll/flexdll.c
@@ -0,0 +1,488 @@
+/*****************************************************************
+   FlexDLL
+   Alain Frisch
+
+   Copyright 2007 Institut National de Recherche en Informatique et
+   en Automatique.
+
+******************************************************************/
+
+/* Runtime support library */
+
+#include <stdio.h>
+#include <string.h>
+#include <windows.h>
+#include "flexdll.h"
+
+/* Guard against compiling with the wrong cl! */
+#ifdef MSVC
+#if defined(_M_AMD64) && !defined(MSVC64)
+#error 64-bit cl selected for a 32-bit build
+#elif !defined(_M_AMD64) && defined(MSVC64)
+#error 32-bit cl selected for a 64-bit build
+#endif
+#endif /* MSVC */
+
+typedef long intnat;
+typedef unsigned long uintnat;
+
+#define RELOC_REL32     0x0001
+#define RELOC_ABS       0x0002
+#define RELOC_REL32_4   0x0003
+#define RELOC_REL32_1   0x0004
+#define RELOC_REL32_2   0x0005
+#define RELOC_DONE      0x0100
+
+typedef struct { UINT_PTR kind; char *name; UINT_PTR *addr; } reloc_entry;
+typedef struct { char *first; char *last; DWORD old; } nonwr;
+typedef struct { nonwr *nonwr; reloc_entry entries[]; } reloctbl;
+typedef struct { void *addr; char *name; } dynsymbol;
+typedef struct { UINT_PTR size; dynsymbol entries[]; } symtbl;
+typedef struct dlunit {
+  void *handle;
+  symtbl *symtbl;
+  int global;
+  int count;
+  struct dlunit *next,*prev;
+} dlunit;
+typedef void *resolver(void*, const char*);
+
+static int error = 0;
+static char error_buffer[256];
+
+/* Emulate a low-level dlopen-like interface */
+
+#ifdef __CYGWIN__
+
+/* Under Cygwin, use the dlopen interface to allow POSIX paths */
+
+#include <dlfcn.h>
+
+static void *ll_dlopen(const char *libname, int for_execution) {
+  return dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+  /* Could use RTLD_LAZY if for_execution == 0, but needs testing */
+}
+
+static void ll_dlclose(void * handle)
+{
+  dlclose(handle);
+}
+
+static void * ll_dlsym(void * handle, char * name)
+{
+  return dlsym(handle, name);
+}
+
+static char * ll_dlerror(void)
+{
+  return dlerror();
+}
+
+#else
+
+static void *ll_dlopen(const wchar_t *libname, int for_execution) {
+  HMODULE m;
+  m = LoadLibraryExW(libname, NULL,
+                     for_execution ? 0 : DONT_RESOLVE_DLL_REFERENCES);
+  /* See https://blogs.msdn.microsoft.com/oldnewthing/20050214-00/?p=36463
+     Should use LOAD_LIBRARY_AS_DATAFILE instead of DONT_RESOLVE_DLL_REFERENCES? */
+
+  /* Under Win 95/98/ME, LoadLibraryEx can fail in cases where LoadLibrary
+     would succeed.  Just try again with LoadLibrary for good measure. */
+  if (m == NULL) m = LoadLibraryW(libname);
+  return (void *) m;
+}
+
+
+static void ll_dlclose(void *handle) {
+  FreeLibrary((HMODULE) handle);
+}
+
+static void *ll_dlsym(void *handle, char *name) {
+  return (void *) GetProcAddress((HMODULE) handle, name);
+}
+
+static char *ll_dlerror(void)
+{
+  DWORD msglen =
+    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+                  NULL,           /* message source */
+                  GetLastError(), /* error number */
+                  0,              /* default language */
+                  error_buffer,         /* destination */
+                  sizeof(error_buffer), /* size of destination */
+                  NULL);          /* no inserts */
+  if (msglen == 0) return "unknown error";
+  else return error_buffer;
+}
+
+#endif
+
+/** Relocation tables **/
+
+static void dump_reloctbl(reloctbl *tbl) {
+  reloc_entry *ptr;
+  nonwr *wr;
+
+  if (!tbl) { printf("No relocation table\n"); return; }
+  printf("Dynamic relocation table found at %p\n", tbl);
+
+  for (wr = tbl->nonwr; wr->last != 0; wr++)
+    printf(" Non-writable relocation in zone %p -> %p\n",
+	   wr->first,
+	   wr->last);
+
+  for (ptr = tbl->entries; ptr->kind; ptr++)
+    printf(" %p (kind:%04lx) (now:%p)  %s\n",
+	   (void *)ptr->addr,
+	   (unsigned long)ptr->kind,
+	   (void *)((UINT_PTR)(*((uintnat*) ptr->addr))),
+	   ptr->name
+	   );
+}
+
+static void dump_master_reloctbl(reloctbl **ptr) {
+  if (!ptr) return;
+  while (*ptr) dump_reloctbl(*ptr++);
+}
+
+/* Avoid the use of snprintf */
+static void cannot_resolve_msg(char *name) {
+  static char msg[] = "Cannot resolve ";
+  static int l = sizeof(msg) - 1;
+  int n = strlen(name);
+  memcpy(error_buffer,msg,l);
+  memcpy(error_buffer+l,name,min(n,sizeof(error_buffer) - l - 1));
+  error_buffer[l+n] = 0;
+}
+
+static void relocate(resolver f, void *data, reloctbl *tbl) {
+  reloc_entry *ptr;
+  nonwr *wr;
+  INT_PTR s;
+  DWORD prev_protect;
+  static long int page_size = 0;
+  SYSTEM_INFO si;
+  char *page_start, *page_end;
+  char *prev_page_start = (char*)1, *prev_page_end = (char*)1;
+
+  if (!tbl) return;
+
+  if (0 == page_size) {
+    GetSystemInfo (&si);
+    page_size = si.dwPageSize;
+  }
+
+  for (ptr = tbl->entries; ptr->kind; ptr++) {
+    if (ptr->kind & RELOC_DONE) continue;
+
+    s = (UINT_PTR) f(data,ptr->name);
+    if (!s) {
+      error = 2;
+      cannot_resolve_msg(ptr->name);
+      goto restore;
+    }
+
+    /* Set up page protection to allow the relocation.  We will undo
+       the change on the next relocation if it falls in a different
+       page (or at the end of the process), to avoid too many calls to
+       VirtualProtect.
+
+       prev_page_start, prev_page_end, prev_protect: describe the
+       protection to be reset.
+
+       Note that a single relocation can fall between two pages.
+    */
+
+    page_start = (char*)ptr->addr;
+    page_end = page_start+((ptr->kind & 0xff) == RELOC_ABS ? sizeof(UINT_PTR) - 1 : 3);
+    page_start -= (size_t) page_start % page_size;
+    page_end -= (size_t) page_end % page_size;
+
+    if (prev_page_start != page_start || prev_page_end != page_end) {
+      if (prev_page_start != (char*)1) {
+        /* Restore */
+        if (0 == VirtualProtect(prev_page_start, prev_page_end-prev_page_start+page_size, prev_protect, &prev_protect)) {
+          fprintf(stderr, "natdynlink: VirtualProtect failed (%s), page_start = 0x%p\n", ll_dlerror(), page_start);
+          exit(2);
+        }
+      }
+
+      prev_page_start = page_start;
+      prev_page_end = page_end;
+      if (0 == VirtualProtect(page_start, page_end-page_start+page_size, PAGE_READWRITE, &prev_protect)) {
+        fprintf(stderr, "natdynlink: VirtualProtect failed (%s), page_start = 0x%p\n", ll_dlerror(), page_start);
+        exit(2);
+      }
+    }
+
+    switch (ptr->kind & 0xff) {
+    case RELOC_ABS:
+      *(ptr->addr) += s;
+      break;
+    case RELOC_REL32:
+      s -= (INT_PTR)(ptr -> addr) + 4;
+      s += *((INT32*) ptr -> addr);
+      if (s != (INT32) s) {
+        sprintf(error_buffer, "flexdll error: cannot relocate %s RELOC_REL32, target is too far: %p  %p", ptr->name, (void *)((UINT_PTR) s), (void *) ((UINT_PTR)(INT32) s));
+        error = 3;
+        goto restore;
+      }
+      *((UINT32*) ptr->addr) = s;
+      break;
+    case RELOC_REL32_4:
+      s -= (INT_PTR)(ptr -> addr) + 8;
+      s += *((INT32*) ptr -> addr);
+      if (s != (INT32) s) {
+        sprintf(error_buffer, "flexdll error: cannot relocate RELOC_REL32_4, target is too far: %p  %p",(void *)((UINT_PTR) s), (void *) ((UINT_PTR)(INT32) s));
+        error = 3;
+        goto restore;
+      }
+      *((UINT32*) ptr->addr) = s;
+      break;
+    case RELOC_REL32_1:
+      s -= (INT_PTR)(ptr -> addr) + 5;
+      s += *((INT32*) ptr -> addr);
+      if (s != (INT32) s) {
+        sprintf(error_buffer, "flexdll error: cannot relocate RELOC_REL32_1, target is too far: %p  %p",(void *)((UINT_PTR) s), (void *) ((UINT_PTR)(INT32) s));
+        error = 3;
+        goto restore;
+      }
+      *((UINT32*) ptr->addr) = s;
+      break;
+    case RELOC_REL32_2:
+      s -= (INT_PTR)(ptr -> addr) + 6;
+      s += *((INT32*) ptr -> addr);
+      if (s != (INT32) s) {
+        sprintf(error_buffer, "flexdll error: cannot relocate RELOC_REL32_2, target is too far: %p  %p",(void *)((UINT_PTR) s), (void *) ((UINT_PTR)(INT32) s));
+        error = 3;
+        goto restore;
+      }
+      *((UINT32*) ptr->addr) = s;
+      break;
+    default:
+      fprintf(stderr, "flexdll: unknown relocation kind");
+      exit(2);
+    }
+    ptr->kind |= RELOC_DONE;
+  }
+ restore:
+  /* Restore page permission */
+  if (prev_page_start != (char*)1) {
+    if (0 == VirtualProtect(prev_page_start, prev_page_end-prev_page_start+page_size, prev_protect, &prev_protect)) {
+      fprintf(stderr, "natdynlink: VirtualProtect failed (%s), page_start = 0x%p\n", ll_dlerror(), page_start);
+      exit(2);
+    }
+  }
+}
+
+static void relocate_master(resolver f, void *data, reloctbl **ptr) {
+  while (0 == error && *ptr) relocate(f,data,*ptr++);
+}
+
+/* Symbol tables */
+
+static void dump_symtbl(symtbl *tbl)
+{
+  int i;
+
+  if (!tbl) { printf("No symbol table\n"); return; }
+  printf("Dynamic symbol at %p (size = %u)\n", tbl, (unsigned int) tbl->size); fflush(stdout);
+
+  for (i = 0; i < tbl->size; i++) {
+    printf("[%i] ", i); fflush(stdout);
+    printf(" %p: ", tbl->entries[i].addr); fflush(stdout);
+    printf("%s\n", tbl->entries[i].name);
+    fflush(stdout);
+  }
+}
+
+static int compare_dynsymbol(const void *s1, const void *s2) {
+  return strcmp(((dynsymbol*) s1) -> name, ((dynsymbol*) s2) -> name);
+}
+
+static void *find_symbol(symtbl *tbl, const char *name) {
+  static dynsymbol s;
+  dynsymbol *sym;
+
+  if (!tbl) return NULL;
+
+  s.name = (char*) name;
+  sym =
+    bsearch(&s,&tbl->entries,tbl->size, sizeof(dynsymbol),&compare_dynsymbol);
+
+  return (NULL == sym ? NULL : sym -> addr);
+}
+
+
+
+/* API */
+
+extern symtbl static_symtable;
+static dlunit *units = NULL;
+static dlunit main_unit;
+
+static void push_unit(dlunit *unit) {
+  unit->next = units;
+  unit->prev = NULL;
+  if (units) units->prev = unit;
+  units = unit;
+}
+
+static void unlink_unit(dlunit *unit) {
+  if (unit->prev) unit->prev->next=unit->next;
+  else units=unit->next;
+
+  if (unit->next) unit->next->prev=unit->prev;
+}
+
+static void *find_symbol_global(void *data, const char *name) {
+  void *sym;
+  dlunit *unit;
+
+  if (!name) return NULL;
+  sym = find_symbol(&static_symtable, name);
+  if (sym) return sym;
+
+  for (unit = units; unit; unit = unit->next) {
+    if (unit->global) {
+      sym = find_symbol(unit->symtbl, name);
+      if (sym) {
+	if (unit != units) { unlink_unit(unit); push_unit(unit); }
+	return sym;
+      }
+    }
+  }
+  return NULL;
+}
+
+int flexdll_relocate(void *tbl) {
+  if (!tbl) { printf("No master relocation table\n"); return 0; }
+  relocate_master(find_symbol_global, NULL, tbl);
+  if (error) return 0;
+  return 1;
+}
+
+#ifdef CYGWIN
+void *flexdll_dlopen(const char *file, int mode) {
+#else
+void *flexdll_wdlopen(const wchar_t *file, int mode) {
+#endif
+  void *handle;
+  dlunit *unit;
+  char flexdll_relocate_env[256];
+  int exec = (mode & FLEXDLL_RTLD_NOEXEC ? 0 : 1);
+  void* relocate = (exec ? &flexdll_relocate : 0);
+
+  error = 0;
+  if (!file) return &main_unit;
+
+#ifdef CYGWIN
+  sprintf(flexdll_relocate_env,"%p",relocate);
+  setenv("FLEXDLL_RELOCATE", flexdll_relocate_env, 1);
+#else
+#if __STDC_SECURE_LIB__ >= 200411L && (defined(_MSC_VER) || (defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x600))
+  sprintf(flexdll_relocate_env,"%p",relocate);
+  _putenv_s("FLEXDLL_RELOCATE", flexdll_relocate_env);
+#else
+  {
+    char* s;
+    sprintf(flexdll_relocate_env,"FLEXDLL_RELOCATE=%p",relocate);
+    s = malloc(strlen(flexdll_relocate_env) + 1);
+    strcpy(s, flexdll_relocate_env);
+    putenv(s);
+  }
+#endif /* __STDC_SECURE_LIB__ >= 200411L && (defined(_MSC_VER) || (defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x600)) */
+#endif /* CYGWIN */
+
+  handle = ll_dlopen(file, exec);
+  if (!handle) { if (!error) error = 1; return NULL; }
+
+  unit = units;
+  while ((NULL != unit) && (unit->handle != handle)) unit = unit->next;
+  if (unit) { unit->count++; }
+  else {
+    unit = malloc(sizeof(dlunit));
+    unit->handle = handle;
+    unit->symtbl = ll_dlsym(handle, "symtbl");
+    unit->count = 1;
+    unit->global = 0;
+    push_unit(unit);
+  }
+  if (mode & FLEXDLL_RTLD_GLOBAL) unit->global=1;
+
+  if (exec) {
+    /* Relocation has already been done if the flexdll's DLL entry point
+       is used */
+    flexdll_relocate(ll_dlsym(handle, "reloctbl"));
+    if (error) { flexdll_dlclose(unit); return NULL; }
+  }
+
+  return unit;
+}
+
+#ifndef CYGWIN
+
+void *flexdll_dlopen(const char *file, int mode)
+{
+  wchar_t * p = NULL;
+  int nbr;
+  void * handle;
+
+  if (file) {
+    nbr = MultiByteToWideChar(CP_THREAD_ACP, 0, file, -1, NULL, 0);
+    if (nbr == 0) { if (!error) error = 1; return NULL; }
+    p = malloc(nbr*sizeof(*p));
+    MultiByteToWideChar(CP_THREAD_ACP, 0, file, -1, p, nbr);
+  }
+
+  handle = flexdll_wdlopen(p, mode);
+
+  if (p) free(p);
+
+  return handle;
+}
+
+#endif
+
+void flexdll_dlclose(void *u) {
+  dlunit *unit = u;
+
+  if (NULL == u || u == &main_unit) return;
+  ll_dlclose(unit->handle);
+  unit->count--;
+  if (unit->count == 0) { unlink_unit(unit); free(unit); }
+}
+
+
+void *flexdll_dlsym(void *u, const char *name) {
+  if (u == &main_unit) return find_symbol_global(NULL,name);
+  else if (NULL == u) return find_symbol(&static_symtable,name);
+  else return find_symbol(((dlunit*)u)->symtbl,name);
+}
+
+char *flexdll_dlerror() {
+  switch (error) {
+  case 0: return NULL;
+  case 1: error = 0; return ll_dlerror();
+  case 2: error = 0; return error_buffer;
+  case 3: error = 0; return error_buffer;
+  }
+  return NULL;
+}
+
+void flexdll_dump_exports(void *u) {
+  dlunit *unit = u;
+  if (NULL == u) { dump_symtbl(&static_symtable); }
+  else if (u == &main_unit) {
+    dump_symtbl(&static_symtable);
+    for (unit = units; unit; unit = unit->next)
+      if (unit->global) { dump_symtbl(unit->symtbl); }
+  }
+  else { dump_symtbl(unit->symtbl); }
+}
+
+void flexdll_dump_relocations(void *u) {
+  if (NULL == u || u == &main_unit) return;
+  dump_master_reloctbl(ll_dlsym(((dlunit*)u) -> handle, "reloctbl"));
+}
--- ./flexdll/flexdll.h
+++ ./flexdll/flexdll.h
@@ -0,0 +1,42 @@
+/*****************************************************************
+   FlexDLL
+   Alain Frisch
+
+   Copyright 2007 Institut National de Recherche en Informatique et
+   en Automatique.
+
+******************************************************************/
+
+/* Header for the runtime support library */
+
+#ifndef FLEXDLL_H
+#define FLEXDLL_H
+
+#include <wchar.h>
+
+#define FLEXDLL_RTLD_GLOBAL 0x0001
+#define FLEXDLL_RTLD_LOCAL  0x0000
+#define FLEXDLL_RTLD_NOEXEC 0x0002
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+void *flexdll_dlopen(const char *, int);
+#ifndef CYGWIN
+void *flexdll_wdlopen(const wchar_t *, int);
+#endif
+
+void *flexdll_dlsym(void *, const char *);
+void flexdll_dlclose(void *);
+char *flexdll_dlerror(void);
+
+void flexdll_dump_exports(void *);
+void flexdll_dump_relocations(void *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ./flexdll/flexdll_initer.c
+++ ./flexdll/flexdll_initer.c
@@ -0,0 +1,55 @@
+/*****************************************************************
+   FlexDLL
+   Alain Frisch
+
+   Copyright 2007 Institut National de Recherche en Informatique et
+   en Automatique.
+
+******************************************************************/
+
+/* Custom entry point to perform relocations before the real
+   entry point is called */
+
+/* The adress of the flexdll_relocate function is passed in an
+   environment variable. This is ugly, but I couldn't find a cleaner
+   solution. Let me know if you have some idea! */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <windows.h>
+
+typedef int func(void*);
+
+extern int reloctbl;
+
+static int flexdll_init() {
+  func *sym = 0;
+  char *s = getenv("FLEXDLL_RELOCATE");
+  if (!s) { fprintf(stderr, "Cannot find FLEXDLL_RELOCATE\n"); return FALSE; }
+  sscanf(s,"%p",&sym);
+  /* sym = 0 means "loaded not for execution" */
+  if (!sym || sym(&reloctbl)) return TRUE;
+  return FALSE;
+}
+
+#ifdef __GNUC__
+#ifdef __CYGWIN__
+#define entry  _cygwin_dll_entry
+#endif
+#ifdef __MINGW32__
+#define entry DllMainCRTStartup
+#endif
+#else
+#define entry _DllMainCRTStartup
+#endif
+
+
+BOOL WINAPI entry(HINSTANCE, DWORD, LPVOID);
+
+BOOL WINAPI FlexDLLiniter(HINSTANCE hinstDLL, DWORD fdwReason,
+			  LPVOID lpReserved) {
+  if (fdwReason == DLL_PROCESS_ATTACH && !flexdll_init())
+    return FALSE;
+
+  return entry(hinstDLL, fdwReason, lpReserved);
+}
--- ./flexdll/reloc.ml
+++ ./flexdll/reloc.ml
@@ -0,0 +1,1596 @@
+(************************************************************************)
+(*   FlexDLL                                                            *)
+(*   Alain Frisch                                                       *)
+(*                                                                      *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et   *)
+(*   en Automatique.                                                    *)
+(************************************************************************)
+
+(* The main application: parse COFF files,
+   compute relocation and export tables, rewrite some COFF files,
+   call the native linker *)
+
+open Coff
+open Cmdline
+
+let debug ?(dry_mode = {contents=false}) min_level fmt =
+  let print msg =
+    if !dry_mode || !verbose >= min_level then
+      Printf.printf "%s\n%!" msg
+  in
+    Printf.ksprintf print fmt
+
+let search_path = ref []
+let default_libs = ref []
+
+let gcc = ref "gcc"
+let objdump = ref "objdump"
+
+let is_crt_lib = function
+  | "LIBCMT"
+  | "MSVCRT" -> true
+  | _ -> false
+
+let ext_obj () =
+  if !toolchain = `MSVC || !toolchain = `MSVC64 then ".obj" else ".o"
+
+(* Temporary files *)
+
+let temps = ref []
+
+let add_temp fn =
+  temps := fn :: !temps; fn
+
+let temp_file s x =
+  add_temp (Filename.temp_file s x)
+
+let open_temp_file s x =
+  let (f, c) = Filename.open_temp_file s x in (add_temp f, c)
+
+let safe_remove s =
+  try Sys.remove s
+  with Sys_error _ -> ()
+
+let () =
+  at_exit
+    (fun () -> if not !save_temps then List.iter safe_remove !temps)
+
+let generic_quote quotequote s =
+  let l = String.length s in
+  let b = Buffer.create (l + 20) in
+  Buffer.add_char b '\'';
+  for i = 0 to l - 1 do
+    if s.[i] = '\''
+    then Buffer.add_string b quotequote
+    else Buffer.add_char b  s.[i]
+  done;
+  Buffer.add_char b '\'';
+  Buffer.contents b
+
+let unix_quote = generic_quote "'\\''"
+
+(* Calling external commands *)
+
+let read_file fn =
+  let ic = open_in fn in
+  let r = ref [] in
+  (try while true do r := input_line ic :: !r done with End_of_file -> ());
+  close_in ic;
+  List.rev !r
+
+(* This is the longest command which can be passed to [Sys.command] *)
+let max_command_length =
+  let processor = try Sys.getenv "COMSPEC" with Not_found -> "cmd.exe" in
+  (* The 4 is from the " /c " *)
+  8191 - String.length processor - 4
+
+let split_path_win str =
+  let rec aux pos =
+    try
+      let i = String.index_from str pos ';' in
+      let len = i - pos in
+      if len = 0 then
+        aux (succ i)
+      else
+        String.sub str pos (i - pos) :: aux (succ i)
+    with Not_found | Invalid_argument _ ->
+      let len = String.length str - pos in
+      if len = 0 then [] else [String.sub str pos len]
+  in
+  aux 0
+
+let windows_shell = lazy begin
+  let rec iter = function
+  | [] -> "bash.exe"
+  | hd::tl ->
+    let bash = Filename.concat hd "bash.exe" in
+    if Sys.file_exists bash = false then iter tl else
+    (* if dash.exe and bash.exe exist in the same dir, choose dash.exe *)
+    let dash = Filename.concat hd "dash.exe" in
+    if Sys.file_exists dash then dash else
+    let sh = Filename.concat hd "sh.exe" in
+    if Sys.file_exists sh then sh else bash
+  in
+  split_path_win (try Sys.getenv "PATH" with Not_found -> "") |> iter
+end
+
+
+let get_output ?(use_bash = false) ?(accept_error=false) cmd =
+  let fn = Filename.temp_file "flexdll" "" in
+  let cmd' = cmd ^ " > " ^ (Filename.quote fn) in
+    if String.length cmd' <= max_command_length && not use_bash then
+      begin
+        if (Sys.command cmd' <> 0) && not accept_error
+        then failwith ("Cannot run " ^ cmd);
+      end
+    else
+      begin
+        let cmd' = cmd ^ " > " ^ (unix_quote fn) in
+        let (cfn, oc) = open_temp_file "longcmd" ".sh" in
+          output_string oc cmd'; close_out oc;
+          let qshell = Filename.quote (Lazy.force windows_shell) in
+          let qcfn =
+            if String.length cfn >= 4 && cfn.[0] = '\\' && cfn.[1] = '\\' && cfn.[2] = '?' && cfn.[3] = '\\' then
+              cfn
+            else
+              String.map (function '\\' -> '/' | c -> c) cfn in
+          let qcfn = Filename.quote qcfn in
+          let cmd = "\"" ^ qshell ^ " " ^ qcfn ^ "\"" in
+          if Sys.command cmd <> 0
+          then failwith ("Cannot run " ^ cmd)
+      end;
+    let r = read_file fn in
+      Sys.remove fn;
+      r
+
+let get_output1 ?use_bash cmd =
+  match get_output ?use_bash cmd with
+  | output::_ -> output
+  | [] -> raise (Failure ("command " ^ cmd ^ " did not return any output"))
+
+let get_output1o ?use_bash cmd =
+  try
+    Some (get_output1 ?use_bash cmd)
+  with
+  | Failure _ -> None
+
+
+(* Preparing command line *)
+
+let mk_dirs_opt ?(unix=false) pr =
+  let quote = match unix with
+  | false -> Filename.quote
+  | true -> unix_quote
+  in
+  String.concat " " (List.map (fun s -> pr ^ (quote s)) !dirs)
+
+exception Not_utf8
+
+let utf8_next s i =
+  let fail () = raise Not_utf8 in
+  let check i =
+    if i >= String.length s then fail ();
+    let n = Char.code s.[i] in
+    if n lsr 6 <> 0b10 then fail () else n
+  in
+  if !i >= String.length s then fail ();
+  match s.[!i] with
+  | '\000'..'\127' as c ->
+      let n = Char.code c in
+      i := !i + 1;
+      n
+  | '\192'..'\223' as c ->
+      let n1 = Char.code c in
+      let n2 = check (!i+1) in
+      let n =
+        ((n1 land 0b11111) lsl 6) lor
+        ((n2 land 0b111111))
+      in
+      i := !i + 2;
+      n
+  | '\224'..'\239' as c ->
+      let n1 = Char.code c in
+      let n2 = check (!i+1) in
+      let n3 = check (!i+2) in
+      let n =
+        ((n1 land 0b1111) lsl 12) lor
+        ((n2 land 0b111111) lsl 6) lor
+        ((n3 land 0b111111))
+      in
+      i := !i + 3;
+      n
+  | '\240'..'\247' as c ->
+      let n1 = Char.code c in
+      let n2 = check (!i+1) in
+      let n3 = check (!i+2) in
+      let n4 = check (!i+3) in
+      let n =
+        ((n1 land 0b111) lsl 18) lor
+        ((n2 land 0b111111) lsl 12) lor
+        ((n3 land 0b111111) lsl 6) lor
+        ((n4 land 0b111111))
+      in
+      i := !i + 4;
+      n
+  | _ ->
+      fail ()
+
+let toutf16 s =
+  let i = ref 0 in
+  let b = Buffer.create (String.length s * 2) in
+  while !i < String.length s do
+    Buffer.add_utf_16le_uchar b (Uchar.unsafe_of_int (utf8_next s i))
+  done;
+  Buffer.contents b
+
+(* Build @responsefile to work around Windows limitations on
+   command-line length *)
+let build_diversion lst =
+  let responsefile = temp_file "camlresp" "" in
+  let oc = open_out_bin responsefile in
+  let lst =
+    List.map (fun f ->
+        let s = Bytes.of_string (Filename.quote f) in
+        for i = 0 to Bytes.length s - 1 do
+          if Bytes.get s i = '\\' then Bytes.set s i '/'
+        done;
+        Bytes.to_string s ^ "\r\n"
+      ) (List.filter (fun f -> f <> "") lst)
+  in
+  let utf16, lst =
+    try true, List.map toutf16 lst
+    with Not_utf8 -> false, lst
+  in
+  if utf16 then output_string oc "\xFF\xFE"; (* LE BOM *)
+  List.iter (fun s -> output_string oc s) lst;
+  close_out oc;
+  "@" ^ responsefile
+
+type cmdline = {
+    may_use_response_file: bool;
+  }
+
+let new_cmdline () =
+  let rf = match !toolchain with
+  | `MSVC | `MSVC64 | `LIGHTLD -> true
+  | `MINGW | `MINGW64 | `GNAT | `GNAT64 | `CYGWIN | `CYGWIN64 -> false
+  in
+  {
+   may_use_response_file = rf;
+  }
+
+let run_command ?(force_bash=false) cmdline cmd =
+  let pipe_to_null = (!toolchain = `MSVC || !toolchain = `MSVC64) in
+  let silencer = if pipe_to_null then " >NUL 2>NUL" else ""
+  in
+  (* note: for Cygwin, using bash allow to follow symlinks to find
+     gcc... *)
+  if !toolchain = `CYGWIN || !toolchain = `CYGWIN64 ||
+     String.length cmd + String.length silencer > max_command_length || force_bash
+  then begin
+    (* Dump the command in a text file and apply bash to it. *)
+    let (fn, oc) = open_temp_file "longcmd" "" in
+    output_string oc cmd;
+    if pipe_to_null then
+      output_string oc " &>/dev/null";
+    close_out oc;
+
+    debug 1 "(call with bash: %s)\n%!" fn;
+    let invoke = Printf.sprintf "bash %s" fn in
+    if Sys.command invoke <> 0 then begin
+      if pipe_to_null then begin
+        let oc = open_out fn in
+        output_string oc cmd;
+        close_out oc;
+        ignore (Sys.command invoke)
+      end;
+      failwith "Error during linking\n"
+    end
+  end else
+    if Sys.command (cmd ^ silencer) <> 0 then begin
+      if pipe_to_null then ignore (Sys.command cmd);
+      failwith "Error during linking\n"
+    end
+
+let quote_files cmdline lst =
+  let s =
+    String.concat " "
+      (List.map (fun f -> if f = "" then f else Filename.quote f) lst) in
+  if String.length s >= 1024 && cmdline.may_use_response_file then Filename.quote (build_diversion lst)
+  else s
+
+
+(* Looking for files *)
+
+let cygpath l =
+  let cmd = Printf.sprintf "cygpath -m %s" (String.concat " " (List.map Filename.quote l)) in
+  if String.length cmd < 7500 then
+    get_output cmd
+  else
+    let cmd = " cygpath -m " ^ (String.concat " " (List.map unix_quote l)) in
+    get_output ~use_bash:true cmd
+
+let cygpath1 fn =
+  get_output1 (Printf.sprintf "cygpath -m %s" fn)
+
+let file_exists fn =
+  if Sys.file_exists fn && not (Sys.is_directory fn) then Some fn
+  else if !use_cygpath && Sys.file_exists (fn ^ ".lnk") then
+    Some (cygpath1 fn)
+  else None
+
+let rec find_file_in = function
+  | [] -> None
+  | fn::rest ->
+      match file_exists fn with
+        | Some x -> Some x
+        | None -> find_file_in rest
+
+let find_file fn =
+  let l =
+    List.flatten
+      (List.map
+         (fun dir ->
+            let fn = Filename.concat dir fn in
+            [ fn; fn ^ ".lib"; fn ^ ".dll.a"; fn ^ ".a" ]
+         ) (""::!search_path)) in
+  match find_file_in l with
+    | Some x -> Some x
+    | None -> if !use_cygpath then find_file_in (cygpath l) else None
+
+let rec map_until_found f = function
+  | [] ->
+      None
+  | x::xs ->
+      match f x with
+      | None ->
+          map_until_found f xs
+      | r ->
+          r
+
+let find_file =
+  let memo = Hashtbl.create 16 in
+  fun fn ->
+    let k = String.lowercase_ascii fn in
+    try Hashtbl.find memo k
+    with Not_found ->
+      try Hashtbl.find memo (k ^ ".lib")
+      with Not_found ->
+        let fns =
+          if String.length fn > 2 && String.sub fn 0 2 = "-l" then
+            let base = String.sub fn 2 (String.length fn - 2) in
+            if !toolchain = `MSVC || !toolchain = `MSVC64 then
+              ["lib" ^ base; base]
+            else
+              ["lib" ^ base]
+          else [fn] in
+        let r =
+          match map_until_found find_file fns with
+          | Some fn -> fn
+          | None ->
+              failwith (Printf.sprintf "Cannot find file %S" fn)
+        in
+        Hashtbl.add memo k r;
+        Hashtbl.add memo (k ^ ".lib") r;
+        r
+
+
+(*******************************)
+
+let int32_to_buf b i =
+  Buffer.add_char b (Char.chr (i land 0xff));
+  Buffer.add_char b (Char.chr ((i lsr 8) land 0xff));
+  Buffer.add_char b (Char.chr ((i lsr 16) land 0xff));
+  Buffer.add_char b (Char.chr ((i lsr 24) land 0xff))
+
+let int_to_buf b i =
+  assert(i >= 0);
+  match !machine with
+  | `x86 -> int32_to_buf b i
+  | `x64 -> int32_to_buf b i; int32_to_buf b 0
+
+let exportable s =
+  match !machine with
+  | `x86 ->
+      s <> "" && (s.[0] = '_' || s.[0] = '?')
+  | `x64 ->
+      if String.length s > 2 && s.[0] = '?' && s.[1] = '?' then false
+      else true
+
+let drop_underscore obj s =
+  match !machine with
+  | `x86 ->
+      assert (s <> "");
+      begin
+        match s.[0] with
+        | '_' -> String.sub s 1 (String.length s - 1)
+        | '?' -> s
+        | _ -> failwith (Printf.sprintf "In %s, symbol %s doesn't start with _ or ?" obj.obj_name s)
+      end
+  | `x64 ->
+      s
+
+let has_prefix pr s =
+  String.length s > String.length pr && String.sub s 0 (String.length pr) = pr
+
+let check_prefix pr s =
+  if has_prefix pr s then
+    Some (String.sub s (String.length pr) (String.length s - String.length pr))
+  else None
+
+let parse_libpath s =
+  let n = String.length s in
+  let rec aux l =
+    if l >= n then []
+    else
+      try
+        let i = String.index_from s l ';' in
+        String.sub s l (i - l) :: aux (succ i)
+      with Not_found -> [ String.sub s l (n - l) ]
+  in
+  aux 0
+
+module StrSet = Set.Make(String)
+
+(* Put all the relocations on the symbols defined by a predicate
+   into a relocation table. A relocation table describes how to
+   patch some addresses with the value of some external symbols (given
+   by their name). It also lists segments that are normally write-protected
+   and that must be de-protected to enable the patching process. *)
+
+let add_reloc_table obj obj_name p =
+  let sname = Symbol.gen_sym () in (* symbol pointing to the reloc table *)
+  let sect = Section.create ".reltbl" 0xc0300040l in
+  let data = Buffer.create 1024 in
+  let strings = Buffer.create 1024 in
+  let nonwr = ref [] in
+  let nonwrsym = Symbol.intern sect 0l in
+  let strsym = Symbol.intern sect 0l in
+  let str_pos = Hashtbl.create 16 in
+
+  Reloc.abs !machine sect 0l nonwrsym;
+  int_to_buf data 0;
+
+  (* TODO: use a single symbol per section *)
+  let syms = ref [] in
+  let reloc secsym min max rel =
+    if p rel.symbol then (
+      (* kind *)
+      let kind = match !machine, rel.rtype with
+        | `x86, 0x06 (* IMAGE_REL_I386_DIR32 *)
+        | `x64, 0x01 (* IMAGE_REL_AMD64_ADDR64 *) ->
+            0x0002 (* absolute, native size (32/64) *)
+
+        | `x64, 0x04 (* IMAGE_REL_AMD64_REL32 *)
+        | `x86, 0x14 (* IMAGE_REL_I386_REL32 *) when not !no_rel_relocs ->
+            0x0001 (* rel32 *)
+
+        | `x64, 0x05 when not !no_rel_relocs -> 0x0004 (* rel32_1 *)
+        | `x64, 0x08 when not !no_rel_relocs-> 0x0003 (* rel32_4 *)
+        | `x64, 0x06 when not !no_rel_relocs-> 0x0005 (* rel32_2 *)
+
+        | (`x86 | `x64), (0x0a (* IMAGE_REL_{I386|AMD64}_SECTION *) |
+                          0x0b (* IMAGE_REL_{I386|AMD64}_SECREL*) ) ->
+            0x0100 (* debug relocs: ignore *)
+
+        | _, k ->
+            let msg =
+              Printf.sprintf "Unsupported relocation kind %04x for %s in %s"
+                k rel.symbol.sym_name obj_name
+            in
+            failwith msg
+(*            Printf.eprintf "%s\n%!" msg;
+            0x0001 *)
+      in
+      int_to_buf data kind;
+
+      (* name *)
+      let name = drop_underscore obj rel.symbol.sym_name in
+      let pos =
+        try Hashtbl.find str_pos name
+        with Not_found ->
+          let pos = Buffer.length strings in
+          Hashtbl.add str_pos name pos;
+          Buffer.add_string strings name;
+          Buffer.add_char strings '\000';
+          pos
+      in
+      Reloc.abs !machine sect (Int32.of_int (Buffer.length data)) strsym;
+      int_to_buf data pos;
+
+      Reloc.abs !machine sect (Int32.of_int (Buffer.length data))
+        (Lazy.force secsym);
+      int_to_buf data (Int32.to_int rel.addr);
+
+      if rel.addr <= !min then min := rel.addr;
+      if rel.addr >= !max then max := rel.addr;
+      false
+    ) else true
+  in
+  let section sec =
+    if sec.sec_opts &&& 0x1000l <> 0l && has_prefix ".rdata$.refptr." sec.sec_name then
+      begin
+        (* under Cygwin64, gcc introduces mergable (link once) COMDAT sections to store
+           indirection pointers to external darta symbols.  Since we don't deal with such section
+           properly, we turn them into regular data section, thus loosing sharing (but we don't care). *)
+        sec.sec_opts <- 0xc0500040l;
+        sec.sec_name <- Printf.sprintf ".flexrefptrsection%i" (Oo.id (object end));
+      end;
+
+    let min = ref Int32.max_int and max = ref Int32.min_int in
+    let sym = lazy (let s = Symbol.intern sec 0l in
+                    syms := s :: !syms;
+                    s) in
+
+    sec.relocs <- filter (reloc sym min max) sec.relocs;
+    if (sec.sec_opts &&& 0x80000000l = 0l) && !min <= !max then
+      nonwr := (!min,!max,Lazy.force sym) :: !nonwr
+  in
+  List.iter section obj.sections;
+  int_to_buf data 0;
+  strsym.value <- Int32.of_int (Buffer.length data);
+  Buffer.add_buffer data strings;
+  nonwrsym.value <- Int32.of_int (Buffer.length data);
+  List.iter
+    (fun (min,max,secsym) ->
+      Reloc.abs !machine sect (Int32.of_int (Buffer.length data)) secsym;
+      int_to_buf data (Int32.to_int min);
+      Reloc.abs !machine sect (Int32.of_int (Buffer.length data)) secsym;
+      int_to_buf data (Int32.to_int max);
+      int_to_buf data 0;
+    )
+    !nonwr;
+  int_to_buf data 0;
+  int_to_buf data 0;
+  sect.data <- `String (Buffer.to_bytes data);
+  obj.sections <- sect :: obj.sections;
+  obj.symbols <-
+    (Symbol.export sname sect 0l) ::
+    strsym :: nonwrsym :: List.filter (fun x -> not (p x)) obj.symbols
+    @ !syms;
+  sname
+
+(* Create a table for import symbols __imp_XXX *)
+
+let add_import_table obj imports =
+  let ptr_size = match !machine with `x86 -> 4 | `x64 -> 8 in
+  let sect = Section.create ".imptbl" 0xc0300040l in
+  obj.sections <- sect :: obj.sections;
+  sect.data <- `String (Bytes.make (ptr_size * List.length imports) '\000');
+  let i = ref 0 in
+  List.iter
+    (fun s ->
+       let sym = Symbol.extern s in
+       obj.symbols <-
+         sym :: Symbol.export ("__imp_" ^ s) sect (Int32.of_int !i) ::
+         obj.symbols;
+       Reloc.abs !machine sect (Int32.of_int !i) sym;
+       i := !i + ptr_size
+    )
+    imports
+
+
+(* Create a table that lists exported symbols (adress,name) *)
+
+let add_export_table obj exports symname =
+  let sect = Section.create ".exptbl" 0xc0300040l in
+  let data = Buffer.create 1024 in
+  let strings = Buffer.create 1024 in
+  let strsym = Symbol.intern sect 0l in
+  obj.symbols <- strsym :: (Symbol.export symname sect 0l) :: obj.symbols;
+  let exports = List.sort Stdlib.compare exports in
+  (* The runtime library assumes that names are sorted! *)
+  int_to_buf data (List.length exports);
+  List.iter
+    (fun s ->
+       let sym = Symbol.extern s in
+       obj.symbols <- sym :: obj.symbols;
+       Reloc.abs !machine sect (Int32.of_int (Buffer.length data)) sym;
+       int_to_buf data 0;
+
+       Reloc.abs !machine sect (Int32.of_int (Buffer.length data)) strsym;
+       int_to_buf data (Buffer.length strings);
+       Buffer.add_string strings (drop_underscore obj s);
+       Buffer.add_char strings '\000';
+    )
+    exports;
+  strsym.value <- Int32.of_int (Buffer.length data);
+  let s = Bytes.cat (Buffer.to_bytes data) (Buffer.to_bytes strings) in
+  sect.data <- `String s;
+  obj.sections <- sect :: obj.sections
+
+(* A master relocation table points to all the relocation tables
+   in the DLL *)
+
+let add_master_reloc_table obj names symname =
+  let sect = Section.create ".mreltbl" 0xc0300040l in
+  let data = Buffer.create 1024 in
+  obj.symbols <- (Symbol.export symname sect 0l) :: obj.symbols;
+  List.iter
+    (fun s ->
+       let sym = Symbol.extern s in
+       obj.symbols <- sym :: obj.symbols;
+       Reloc.abs !machine sect (Int32.of_int (Buffer.length data)) sym;
+       int_to_buf data 0;
+    )
+    names;
+  int_to_buf data 0;
+  sect.data <- `String (Buffer.to_bytes data);
+  obj.sections <- sect :: obj.sections
+
+
+
+let collect_dllexports obj =
+  let dirs = Coff.directives obj in
+  let l =
+    List.map
+      (function
+        | (_,x::_) -> x
+        | _ -> assert false
+      )
+      (List.find_all (fun (cmd,_args) -> String.uppercase_ascii cmd = "EXPORT") dirs)
+  in
+  match !toolchain with
+  | `MSVC | `MSVC64 -> List.map (drop_underscore obj) l
+  | _ -> l
+
+let collect f l =
+  List.fold_left
+    (fun accu x -> match f x with None -> accu | Some y -> y :: accu)
+    []
+    l
+
+let cmd_verbose cmd =
+  debug 1 "+ %s" cmd;
+  Sys.command cmd
+
+
+let parse_dll_exports fn =
+  let ic = open_in fn in
+  let exps = ref [] in
+  try
+    while input_line ic <> "[Ordinal/Name Pointer] Table" do () done;
+    while true do
+      let s = input_line ic in
+      let r = String.index s ']' in
+      let sym = String.sub s (r+2) (String.length s - r - 2) in
+      exps := ("_" ^ sym,0) :: !exps;
+    done;
+    assert false
+  with Not_found | End_of_file ->
+    close_in ic;
+    !exps
+
+
+let dll_exports fn = match !toolchain with
+  | `MSVC | `MSVC64 | `LIGHTLD ->
+      failwith "Creation of import library not supported for this toolchain"
+  | `GNAT | `GNAT64 | `CYGWIN | `CYGWIN64 | `MINGW | `MINGW64 ->
+      let dmp = temp_file "dyndll" ".dmp" in
+      if cmd_verbose (Printf.sprintf "%s -p %s > %s" !objdump fn dmp) <> 0
+      then failwith "Error while extracting exports from a DLL";
+      parse_dll_exports dmp
+
+
+let patch_output filename =
+  match !stack_reserve with
+  | Some x ->
+      let filename =
+        if not (Sys.file_exists filename) && (Sys.file_exists (filename ^ ".exe")) then filename ^ ".exe"
+        else filename
+      in
+      let filename =
+        if !use_cygpath then cygpath1 filename
+        else filename
+      in
+      begin try Stacksize.set_stack_reserve filename x
+      with exn ->
+        Printf.eprintf "Cannot set stack reserve: %s\n%!"
+          (Printexc.to_string exn)
+      end
+  | None -> ()
+
+
+(* Extract the set of external symbols required by an object. *)
+(* If the object requires "__imp_X", and "X" is available in one of the objects/libraries
+   (but not "__imp_X" itself), then we consider that "X" is required.
+   Indeed, we will create "__imp_X" (with a redirection to "X").
+   Collect such cases in "imported".
+*)
+let needed imported defined unalias obj =
+  let rec normalize name =
+    try
+      let r = unalias name in
+      if r <> name then normalize r else r
+    with Not_found -> name
+  in
+  let normalize_imp name =
+    match check_prefix "__imp_" name with
+    | Some s when not (StrSet.mem name defined) ->
+        imported := StrSet.add s !imported;
+        if StrSet.mem s defined then s else name
+    | None when not (StrSet.mem name defined) && StrSet.mem ("__imp_" ^ name) defined ->
+        imported := StrSet.add ("__imp_" ^ name) !imported;
+        "__imp_" ^ name
+    | _ -> name
+  in
+  List.fold_left
+    (fun accu sym ->
+       if Symbol.is_extern sym then StrSet.add (normalize_imp (normalize sym.sym_name)) accu
+       else accu
+    )
+    StrSet.empty
+    obj.symbols
+
+let build_dll link_exe output_file files exts extra_arguments =
+  let extra_args = String.concat " " (List.map Filename.quote extra_arguments) in
+
+
+  let main_pgm = link_exe <> `DLL in
+
+  (* fully resolve filenames, eliminate duplicates *)
+  let _, files =
+    List.fold_left
+      (fun (seen, accu) fn ->
+         let fn = find_file fn in
+         let k = String.lowercase_ascii fn in
+         if StrSet.mem k seen then (seen, accu)
+         else (StrSet.add k seen, fn :: accu)
+      ) (StrSet.empty, []) files in
+  let files = List.rev files in
+
+  (* load given files *)
+  let loaded_filenames : (string,unit) Hashtbl.t = Hashtbl.create 16 in
+  let read_file fn =
+    if Lib.is_dll fn then `Lib ([], dll_exports fn)
+    else begin
+      if !verbose >= 2 then Printf.printf "** open: %s\n" fn;
+      Lib.read fn
+    end
+  in
+  let files = List.map (fun fn -> fn, read_file fn) files in
+
+  List.iter (fun (fn,_) -> Hashtbl.add loaded_filenames fn ()) files;
+
+  let objs = collect (function (f, `Obj x) -> Some (f,x) | _ -> None) files in
+  let libs = collect (function (f, `Lib (x,_)) -> Some (f,x) | _ -> None) files in
+
+  let with_data_symbol symbols sym_name f =
+    if !toolchain <> `MSVC && !toolchain <> `MSVC64 then
+      match check_prefix "__nm_" sym_name with
+      | None -> ()
+      | Some s ->
+        let imp_name = "__imp_" ^ s  in
+        if List.exists ( fun p -> Symbol.is_defin p &&
+          p.sym_name = imp_name) symbols then
+          f s;
+  in
+  (* Collect all the available symbols, including those defined
+     in default libraries *)
+  let defined, from_imports, unalias =
+    let aliases = Hashtbl.create 16 in
+    let defined = ref StrSet.empty in
+    let from_imports = ref StrSet.empty in (* symbols from import libraries *)
+    let add_def s = defined := StrSet.add s !defined in
+
+    let collected = Hashtbl.create 8 in
+    let rec collect_defined_obj obj =
+      (* see comments on Cygwin64 COMDATA sections.  Here we give a
+         unique name to the internal symbol.  We use ?? to ensure the
+         symbol is not exported in flexdll export table (see
+         exportable function) *)
+      List.iter
+        (fun sym ->
+           if has_prefix ".refptr." sym.sym_name then
+             sym.sym_name <- Printf.sprintf "??flexrefptr%i" (Oo.id (object end))
+        )
+        obj.symbols;
+
+      (* Collect aliases *)
+      List.iter
+        (fun (x, y) ->
+           debug 2 "alias %s -> %s" x y;
+           Hashtbl.add aliases x y
+        )
+        (Coff.aliases obj);
+
+
+      (* Iterates through DEFAULTLIB directives *)
+      let register_deflib fn =
+        if not !custom_crt || not (is_crt_lib fn) then
+          let fn = find_file fn in
+          if not (Hashtbl.mem loaded_filenames fn)
+          then (Hashtbl.add loaded_filenames fn (); collect_file fn)
+      in
+      if not !builtin_linker && !use_default_libs then
+        List.iter
+          (fun (cmd, args) ->
+             if String.uppercase_ascii cmd = "DEFAULTLIB" then List.iter register_deflib args
+          )
+          (Coff.directives obj);
+
+      (* Collect defined symbols *)
+      List.iter
+        (fun sym ->
+          if Symbol.is_defin sym then (
+            add_def sym.sym_name;
+            with_data_symbol obj.symbols sym.sym_name add_def)
+        )
+        obj.symbols
+
+    and collect_file fn =
+      if not (Hashtbl.mem collected (String.lowercase_ascii fn)) then begin
+        Hashtbl.replace collected (String.lowercase_ascii fn) ();
+        debug 2 "** open: %s" fn;
+        collect_defined fn (Lib.read fn)
+      end
+
+    and collect_defined fn = function
+      | `Obj obj -> collect_defined_obj obj
+      | `Lib (objs,imports) ->
+          List.iter (fun (_, obj) -> collect_defined_obj obj) objs;
+          List.iter
+            (fun (s,_) ->
+               debug 2 "lib %s import symbol %s" fn s;
+               from_imports := StrSet.add s !from_imports;
+               add_def s;
+               add_def ("__imp_" ^ s)
+            )
+            imports
+    in
+    List.iter
+      (fun (fn,x) ->
+         Hashtbl.replace collected (String.lowercase_ascii fn) ();
+         collect_defined fn x
+      )
+      files;
+    if !use_default_libs then List.iter (fun fn -> collect_file (find_file fn)) !default_libs;
+    List.iter (fun fn -> collect_file (find_file fn)) exts;
+
+    if main_pgm then add_def (usym "static_symtable")
+    else add_def (usym "reloctbl");
+
+    if !machine = `x64 then add_def "__ImageBase"
+    else add_def "___ImageBase";
+
+    !defined, !from_imports, (Hashtbl.find aliases)
+  in
+
+  (* Determine which objects from the given libraries should be linked
+     in. First step: find the mapping (symbol -> object) for these
+     objects. *)
+  let defined_in =
+    let defined_in = Hashtbl.create 16 in
+    let def_in_obj fn (objname, obj) =
+      List.iter
+        (fun sym ->
+           if Symbol.is_defin sym
+           then begin
+             let f s =
+               if !explain then
+                 Printf.printf "Symbol %s found in %s(%s)\n%!" s fn objname;
+               Hashtbl.replace defined_in s (fn,objname,obj);
+             in
+             f sym.sym_name;
+             with_data_symbol obj.symbols sym.sym_name f
+           end
+        )
+        obj.symbols
+    in
+    List.iter
+      (fun (fn,objs) ->
+         if !explain then Printf.printf "Scanning lib %s\n%!" fn;
+         List.iter (def_in_obj fn) objs
+      )
+      libs;
+    Hashtbl.find defined_in
+  in
+
+  let imported_from_implib = ref StrSet.empty in
+  let imported = ref StrSet.empty in
+
+  let imports obj =
+    let n = needed imported defined unalias obj in
+    imported_from_implib := StrSet.union !imported_from_implib (StrSet.inter n from_imports);
+    let undefs = StrSet.diff n defined in
+    StrSet.filter
+      (fun s ->
+         match check_prefix "__imp_" s with
+         | Some _ -> false
+         | None -> s <> "environ"  (* special hack for Cygwin64 *)
+      )
+      undefs
+  in
+
+  (* Second step: transitive closure, starting from given objects *)
+
+  let libobjects = Hashtbl.create 16 in
+  let reloctbls = ref [] in
+  let exported = ref StrSet.empty in
+
+  List.iter (fun s -> exported := StrSet.add (usym s) !exported) !defexports;
+
+  let record_obj obj =
+    if !builtin_linker then ""
+    else begin
+      let fn = temp_file "dyndll" (ext_obj ()) in
+      let oc = open_out_bin fn in
+      Coff.put oc obj;
+      close_out oc;
+      fn
+    end
+  in
+
+  let add_reloc name obj imps =
+    if !show_imports && not (StrSet.is_empty imps) then (
+      Printf.printf "** Imported symbols for %s:\n%!" name;
+      StrSet.iter print_endline imps
+    );
+    let sym = add_reloc_table obj name (fun s -> StrSet.mem s.sym_name imps) in
+    reloctbls := sym :: !reloctbls
+  in
+
+  let errors = ref false in
+  let error_imports name imps =
+    if main_pgm then begin
+      Printf.eprintf "** Cannot resolve symbols for %s:\n %s\n%!"
+        name
+        (String.concat "\n " (StrSet.elements imps));
+      errors := true
+    end
+  in
+
+  let close_obj name imps obj =
+    error_imports name imps;
+    add_reloc name obj imps;
+    record_obj obj
+  in
+
+  let dll_exports = ref StrSet.empty in
+  let rec link_obj fn obj =
+    List.iter
+      (fun sym ->
+         if Symbol.is_defin sym && exportable sym.sym_name
+         then exported := StrSet.add sym.sym_name !exported
+      )
+      obj.symbols;
+
+    dll_exports := List.fold_left (fun accu x -> StrSet.add x accu)
+        !dll_exports (collect_dllexports obj);
+    StrSet.iter
+      (fun s ->
+        if StrSet.mem s !exported then ()
+        else
+          try
+            let (libname, objname, _) as o = defined_in s in
+            if !explain then
+              Printf.printf "%s -> %s(%s) because of %s\n%!" fn libname objname s;
+            link_libobj o
+          with Not_found ->
+            if !explain then
+              Printf.printf "%s needs %s (not found)\n%!" fn s
+      )
+      (needed imported defined unalias obj)
+
+  and link_libobj (libname,objname,obj) =
+    if Hashtbl.mem libobjects (libname,objname) then ()
+    else (Hashtbl.replace libobjects (libname,objname) (obj,imports obj);
+          link_obj (Printf.sprintf "%s(%s)" libname objname) obj)
+  in
+
+  let redirect = Hashtbl.create 16 in
+  List.iter
+    (fun (fn, obj) ->
+       link_obj fn obj;
+       let imps = imports obj in
+       if StrSet.is_empty imps then ()
+       else Hashtbl.replace redirect fn (close_obj fn imps obj);
+    ) objs;
+
+  let need_lib = Hashtbl.create 16 in
+  Hashtbl.iter
+    (fun (libname,objname) (obj,imps) ->
+      if StrSet.is_empty imps
+      then Hashtbl.replace need_lib libname ()
+          (* the linker will find this object in this library *)
+      else begin
+        if !explain then
+          Printf.printf "Library object %s(%s) needs to be rewritten\n%!"
+            libname objname;
+        Hashtbl.add redirect libname
+          (close_obj (Printf.sprintf "%s(%s)" libname objname) imps obj)
+      end
+    )
+    libobjects;
+
+  if !show_exports then (
+    Printf.printf "** Exported symbols:\n";
+    StrSet.iter print_endline !exported;
+    Printf.printf "** Symbols from import libs:\n";
+    StrSet.iter print_endline !imported_from_implib;
+    flush stdout
+  );
+
+  if !reexport_from_implibs then
+    exported := StrSet.union !exported !imported_from_implib;
+
+  (* Create the descriptor object *)
+  let obj = Coff.create !machine in
+
+  if not (StrSet.is_empty !imported) then begin
+(*
+    Printf.printf "** __imp symbols:\n%!";
+    StrSet.iter print_endline !imported;
+*)
+    add_import_table obj (StrSet.elements !imported);
+    let undef_imports = StrSet.diff !imported defined in
+    if not (StrSet.is_empty undef_imports) then begin
+      error_imports "descriptor object" undef_imports;
+      add_reloc "descriptor object" obj undef_imports;
+    end
+  end;
+
+  add_export_table obj (if !noexport then [] else StrSet.elements !exported)
+    (usym (if main_pgm then "static_symtable" else "symtbl"));
+  if not main_pgm then add_master_reloc_table obj !reloctbls (usym "reloctbl");
+
+  if !errors then
+    exit 2;
+
+  if !builtin_linker then begin
+    let objs = List.map
+        (function
+           | (_, `Obj obj) -> obj
+           | (fn, _) -> failwith ("File is not an object file: " ^ fn)
+        ) files
+    in
+    let oc = open_out_bin output_file in
+    Create_dll.create_dll oc (List.rev (obj :: objs));
+    close_out oc
+  end else
+
+  let descr = record_obj obj in
+  let files =
+    List.flatten
+      (List.map
+         (fun (fn,d) ->
+           let all = Hashtbl.find_all redirect fn in
+           if all = [] then [fn]
+           else
+             match d with
+             | `Lib _ when Hashtbl.mem need_lib fn -> all @ [fn]
+             | `Lib (_, []) | `Obj _ -> all
+             | `Lib _ -> all @ [fn]
+            (* Note: extracted object have higher priorities
+               than objects embedded in the library, so this is ok.
+               We always keep libraries with import symbols.
+               For mingw, it is necessary to put the library after
+               extracted objects. *)
+         )
+         files
+      )
+    @ exts in
+
+  let cmdline = new_cmdline () in
+  let files_unquoted = files in
+  let files = quote_files cmdline files in
+  let descr_unquoted = descr in
+  let descr = Filename.quote descr in
+
+  begin
+    match !deffile with
+    | Some x when not !dry_mode ->
+        let fn =
+          if x = "" then Filename.chop_extension output_file ^ ".def"
+          else x
+        in
+        debug 1 "Generate %s" fn;
+        let oc = open_out fn in
+        Printf.fprintf oc "LIBRARY %s\n" output_file;
+        Printf.fprintf oc "EXPORTS\n";
+        StrSet.iter (Printf.fprintf oc "  %s\n") !dll_exports;
+        close_out oc
+    | _ -> ()
+  end;
+
+  let force_bash,cmd = match !toolchain with
+    | `MSVC | `MSVC64 ->
+        (* Putting the file the descriptor object at the beginning
+           with MSVC compilers seems to break Stack overflow recovery
+           in OCaml. No idea why. *)
+
+        let implib =
+          if !implib then
+            Filename.chop_extension output_file ^ ".lib"
+          else
+            temp_file "dyndll_implib" ".lib"
+        in
+        (* VS 2017.3 doesn't seem to be able to cope with /implib: existing but
+           being an empty file. *)
+        let c = open_out implib in output_string c "x"; close_out c;
+        let _impexp = add_temp (Filename.chop_suffix implib ".lib" ^ ".exp") in
+        let extra_args =
+          if !custom_crt then "/nodefaultlib:LIBCMT /nodefaultlib:MSVCRT " ^ extra_args
+          else "msvcrt.lib " ^ extra_args
+        in
+        let extra_args =
+          if !machine <> `x86 || link_exe <> `EXE || !oasis_hack = false || !subsystem <> "console" then
+            extra_args
+          else
+            match String.lowercase_ascii output_file with
+            | "setup.exe" | "setup-dev.exe" ->
+                "/MANIFEST /MANIFESTUAC:\"level='asInvoker'\" /manifest:embed " ^ extra_args
+            | _ -> extra_args
+        in
+
+        let extra_args =
+          if !machine = `x64 then (Printf.sprintf "/base:%s " !base_addr) ^ extra_args else extra_args
+        in
+
+        let extra_args =
+          (* FlexDLL doesn't process .voltbl sections correctly, so don't allow the linker
+             to process them. *)
+          if Sys.command "link | findstr EMITVOLATILEMETADATA > nul" = 0 then
+            "/EMITVOLATILEMETADATA:NO " ^ extra_args
+          else extra_args
+        in
+
+        (* Flexdll requires that all images (main programs and all the DLLs) are
+           not too far away. This is needed because of the 32-bit relative relocations
+           (e.g. function calls). It seems that passing such a /base argument to link.exe
+           gives some hope that this will be the case. Problems observed otherwise
+           with the Windows 7 SDK in 64-bit mode. *)
+
+        false,Printf.sprintf
+          "link /nologo %s%s%s%s%s /implib:%s /out:%s /subsystem:%s %s %s %s"
+          (if !verbose >= 2 then "/verbose " else "")
+          (if link_exe = `EXE then "" else "/dll ")
+          (if main_pgm then "" else "/export:symtbl /export:reloctbl ")
+          (if main_pgm then "" else if !noentry then "/noentry " else
+          let s =
+            match !machine with
+            | `x86 -> "FlexDLLiniter@12"
+            | `x64 -> "FlexDLLiniter"
+          in
+          Printf.sprintf "/entry:%s " s
+          )
+          (mk_dirs_opt "/libpath:")
+          (Filename.quote implib)
+          (Filename.quote output_file)
+          !subsystem
+          files descr
+          extra_args
+    | `CYGWIN | `CYGWIN64 ->
+        let def_file =
+          if main_pgm then ""
+          else
+            let def_file, oc = open_temp_file "flexlink" ".def" in
+            Printf.fprintf oc "EXPORTS\n  reloctbl\n  symtbl\n";
+            close_out oc;
+            Filename.quote def_file
+        in
+        false,Printf.sprintf
+          "%s %s%s -L. %s %s -o %s %s %s %s %s"
+          !gcc
+          (if link_exe = `EXE then "" else "-shared ")
+          (if main_pgm then "" else if !noentry then "-Wl,-e0 " else if !machine = `x86 then "-Wl,-e_FlexDLLiniter@12 " else "-Wl,-eFlexDLLiniter ")
+          (mk_dirs_opt "-I")
+          (mk_dirs_opt "-L")
+          (Filename.quote output_file)
+          descr
+          files
+          def_file
+          extra_args
+    | `MINGW | `MINGW64 | `GNAT | `GNAT64 ->
+        let def_file =
+          if main_pgm then ""
+          else
+            let def_file, oc = open_temp_file "flexlink" ".def" in
+            Printf.fprintf oc "EXPORTS\n  reloctbl\n  symtbl\n";
+            close_out oc;
+        def_file
+      in
+      let extra_args =
+        if !machine = `x64 then
+          Printf.sprintf "-Xlinker --image-base -Xlinker %s %s" !base_addr extra_args
+        else
+          extra_args
+      in
+      let cmd =
+        let def_file = match def_file with
+        | "" -> ""
+        | x -> Filename.quote x
+        in
+        Printf.sprintf
+          "%s -m%s %s%s -L. %s %s -o %s %s %s %s %s %s"
+          !gcc
+          !subsystem
+          (if link_exe = `EXE then "" else "-shared ")
+          (if main_pgm then "" else if !noentry then "-Wl,-e0 " else if !machine = `x86 then "-Wl,-e_FlexDLLiniter@12 " else "-Wl,-eFlexDLLiniter ")
+          (mk_dirs_opt "-I")
+          (mk_dirs_opt "-L")
+          (Filename.quote output_file)
+          descr
+          files
+          def_file
+          (if !implib then "-Wl,--out-implib=" ^ Filename.quote (Filename.chop_extension output_file ^ ".a") else "")
+          extra_args
+      in
+      if String.length cmd < 7_500 then
+        false,cmd
+      else
+        let def_file = match def_file with
+        | "" -> ""
+        | x -> unix_quote x
+        in
+        let descr = unix_quote descr_unquoted in
+        let files =
+          String.concat " "
+            (List.map (fun f -> if f = "" then f else unix_quote f) files_unquoted)
+        in
+        let extra_args_unix = String.concat " " (List.map unix_quote extra_arguments) in
+        true,Printf.sprintf
+          "%s -m%s %s%s -L. %s %s -o %s %s %s %s %s %s"
+          !gcc
+          !subsystem
+          (if link_exe = `EXE then "" else "-shared ")
+          (if main_pgm then "" else if !noentry then "-Wl,-e0 " else if !machine = `x86 then "-Wl,-e_FlexDLLiniter@12 " else "-Wl,-eFlexDLLiniter ")
+          (mk_dirs_opt ~unix:true "-I")
+          (mk_dirs_opt ~unix:true "-L")
+          (unix_quote output_file)
+          descr
+          files
+          def_file
+          (if !implib then "-Wl,--out-implib=" ^ unix_quote (Filename.chop_extension output_file ^ ".a") else "")
+          extra_args_unix
+    | `LIGHTLD ->
+        no_merge_manifest := true;
+        false,Printf.sprintf
+          "ld %s%s -o %s %s %s %s %s"
+          (if link_exe = `EXE then "" else "--shared ")
+          (if main_pgm then "" else if !noentry then "-e0 " else "-e FlexDLLiniter@12 ")
+          (Filename.quote output_file)
+          descr
+          files
+          (if !implib then "--out-implib " ^ Filename.quote (Filename.chop_extension output_file ^ ".a") else "")
+          extra_args
+  in
+  debug ~dry_mode 1 "+ %s" cmd;
+  if not !dry_mode then begin
+    let manifest_file = output_file ^ ".manifest" in
+    safe_remove manifest_file;
+    run_command ~force_bash cmdline cmd;
+
+    if (not !no_merge_manifest) && !merge_manifest && (not !real_manifest || Sys.file_exists manifest_file)
+    then begin
+      let fn =
+        if !real_manifest then manifest_file
+        else
+          let default_manifest =
+            match !machine with
+            | `x86 -> "default.manifest"
+            | `x64 -> "default_amd64.manifest"
+          in
+          Filename.concat flexdir default_manifest
+      in
+      let mcmd =
+        Printf.sprintf "mt -nologo -outputresource:%s -manifest %s"
+          (Filename.quote (if link_exe = `EXE then output_file
+                           else output_file ^ ";#2"))
+          (Filename.quote fn)
+      in
+      debug 1 "+ %s" mcmd;
+      if Sys.command mcmd <> 0 then
+        failwith "Error while merging the manifest";
+      safe_remove manifest_file;
+    end;
+    patch_output output_file
+ end
+
+let ends_with s suf =
+  let rec aux s suf suflen offset i =
+    i >= suflen || (s.[i + offset] = suf.[i]
+                   && aux s suf suflen offset (i+1)) in
+  let slen = String.length s in
+  let suflen = String.length suf in
+  slen >= suflen && aux s suf suflen (slen - suflen) 0
+
+let strip s =
+  let rec search i s =
+    if s.[i] = ' ' then search (i+1) s
+    else String.sub s i (String.length s - i)
+  in
+  search 0 s
+
+let read_gnatls () =
+   (* This function is used by the GNAT toolchain to compute the include
+      directory. gnatls actually returns with an error code different to 0, so
+      we need to accept the error here. *)
+   let str_l = get_output ~accept_error:true ("gnatls -v") in
+   let ada_include =
+     List.hd (List.filter (fun s -> ends_with s "adainclude") str_l) in
+   Filename.dirname (strip ada_include)
+
+let split str sep =
+  let p = String.index str sep in
+  let slen = String.length str in
+  String.sub str 0 p, String.sub str (p + 1) (slen - p - 1)
+
+let nsplit str sep =
+  if str = "" then []
+  else
+    let rec loop acc pos =
+      if pos > String.length str then
+        List.rev acc
+      else
+        let i = try String.index_from str pos sep with Not_found -> String.length str in
+        loop (String.sub str pos (i - pos) :: acc) (i + 1)
+    in
+    loop [] 0
+
+let normalize_path path =
+  let path = nsplit path '/' in
+  let rec loop acc path =
+    match path with
+    | "."  :: path -> loop acc path
+    | ".." :: path -> begin
+        match acc with
+        | ".." :: _ | [] -> loop (".." :: acc) path
+        | _ :: acc -> loop acc path
+      end
+    | elem :: path -> loop (elem :: acc) path
+    | [] -> List.rev acc
+  in
+  let path = loop [] path in
+  String.concat "/" path
+
+let remove_duplicate_paths paths =
+  let set = Hashtbl.create 16 in
+  let rec loop paths =
+    match paths with
+    | path :: paths ->
+        begin try
+          Hashtbl.find set path;
+          loop paths
+        with Not_found ->
+          Hashtbl.add set path ();
+          path :: loop paths
+        end
+    | [] -> []
+  in
+  loop paths
+
+let setup_toolchain () =
+  let mingw_libs pre =
+    gcc := pre ^ "gcc";
+    objdump := pre ^ "objdump";
+    let rec get_lib_search_dirs input =
+      match input with
+      | entry :: input ->
+          begin try
+            match split entry '=' with
+            | "libraries: ", paths -> nsplit paths ':'
+            | _ -> get_lib_search_dirs input
+          with Not_found ->
+            get_lib_search_dirs input
+          end
+      | [] -> []
+    in
+    let lib_search_dirs =
+      get_output ~use_bash:true ("LC_ALL=C " ^ !gcc ^ " -print-search-dirs")
+      |> get_lib_search_dirs
+      |> List.map normalize_path
+      |> remove_duplicate_paths
+    in
+    search_path := !dirs @ lib_search_dirs;
+    if !verbose >= 1 then begin
+      print_endline "lib search dirs:";
+      List.iter (Printf.printf "  %s\n") lib_search_dirs;
+      flush stdout
+    end;
+    default_libs :=
+      ["-lmingw32"; "-lgcc"; "-lgcc_eh"; "-lmoldname"; "-lmingwex"; "-lmsvcrt";
+       "-luser32"; "-lkernel32"; "-ladvapi32"; "-lshell32" ];
+    if !exe_mode = `EXE then default_libs := "crt2u.o" :: !default_libs
+    else default_libs := "dllcrt2.o" :: !default_libs
+  in
+  match !toolchain with
+  | _ when !builtin_linker ->
+      search_path := !dirs;
+      add_flexdll_obj := false;
+      noentry := true
+  | `CYGWIN | `CYGWIN64 ->
+      gcc := "gcc";
+      objdump := "objdump";
+      search_path :=
+        !dirs @
+          [
+           "/lib";
+           "/lib/w32api";
+           Filename.dirname (get_output1 ~use_bash:true "gcc -print-libgcc-file-name");
+          ];
+      default_libs := ["-lkernel32"; "-luser32"; "-ladvapi32";
+                       "-lshell32"; "-lcygwin"; "-lgcc"]
+  | `MSVC | `MSVC64 ->
+      search_path := !dirs @
+        parse_libpath (try Sys.getenv "LIB" with Not_found -> "");
+      if not !custom_crt then
+        default_libs := ["msvcrt.lib"]
+  | `MINGW ->
+      mingw_libs Version.mingw_prefix
+  | `MINGW64 ->
+      mingw_libs Version.mingw64_prefix
+  | `GNAT | `GNAT64 ->
+   (* This is a plain copy of the mingw version, but we do not change the
+      prefix and use "gnatls" to compute the include dir. *)
+    search_path :=
+      !dirs @
+      [
+       Filename.dirname (get_output1 (!gcc ^ " -print-libgcc-file-name"));
+       read_gnatls ();
+      ];
+    default_libs :=
+      ["-lmingw32"; "-lgcc"; "-lmoldname"; "-lmingwex"; "-lmsvcrt";
+       "-luser32"; "-lkernel32"; "-ladvapi32"; "-lshell32" ];
+    if !exe_mode = `EXE then default_libs := "crt2u.o" :: !default_libs
+    else default_libs := "dllcrt2.o" :: !default_libs
+  | `LIGHTLD ->
+      search_path := !dirs
+
+let display_msvc_output file name =
+  let c = open_in file in
+  try
+    let first = input_line c in
+    if first <> (Filename.basename name) then
+      print_string first;
+    while true do
+      print_string (input_line c)
+    done
+  with _ ->
+    close_in c
+
+let compile_if_needed file =
+  if Filename.check_suffix file ".c" then begin
+    let tmp_obj = temp_file "dyndll" (ext_obj ()) in
+    let (pipe, stdout) =
+      if (!toolchain = `MSVC || !toolchain = `MSVC64) && !verbose < 2 && not !dry_mode then
+        try
+          let (t, c) = open_temp_file "msvc" "stdout" in
+          close_out c;
+          (Printf.sprintf " > %s" (Filename.quote t), t)
+        with _ ->
+          ("", "")
+      else
+        ("", "") in
+    let cmd = match !toolchain with
+      | `MSVC | `MSVC64 ->
+          Printf.sprintf
+            "cl /c /MD /nologo /Fo%s %s %s%s"
+            (Filename.quote tmp_obj)
+            (mk_dirs_opt "/I")
+            file
+            pipe
+      | `CYGWIN | `CYGWIN64 ->
+          Printf.sprintf
+            "gcc -c -o %s %s %s"
+            (Filename.quote tmp_obj)
+            (mk_dirs_opt "-I")
+            file
+      | `MINGW | `MINGW64 | `GNAT | `GNAT64 ->
+          Printf.sprintf
+            "%s -c -o %s %s %s"
+            !gcc
+            (Filename.quote tmp_obj)
+            (mk_dirs_opt "-I")
+            (Filename.quote file)
+      | `LIGHTLD ->
+          failwith "Compilation of C code is not supported for this toolchain"
+    in
+    debug ~dry_mode 1 "+ %s" cmd;
+    let exit = if !dry_mode then 0 else Sys.command cmd in
+    if pipe <> "" then display_msvc_output stdout file;
+    if exit <> 0 then failwith "Error while compiling";
+    tmp_obj
+  end else
+    file
+
+let dump fn =
+  let fn = find_file fn in
+  Printf.printf "*** %s:\n" fn;
+  match Lib.read fn with
+  | `Lib (objs,imports) ->
+      List.iter
+        (fun (n,o) ->
+          Printf.printf "** %s(%s):\n" fn n;
+          Coff.dump o
+        )
+        objs;
+      List.iter
+        (fun (s,i) -> Printf.printf "** import: %s (%i)\n" s i)
+        imports;
+      flush stdout
+  | `Obj o ->
+      Coff.dump o
+
+let all_files () =
+  let files = List.rev (List.map compile_if_needed !files) in
+  let f obj =
+    let fn = Filename.concat flexdir obj in
+    (* Allow the obj files to be stored in a different location *)
+    if file_exists fn <> None then
+      fn
+    else
+      obj in
+  let tc = match !toolchain with
+  | `MSVC -> "msvc.obj"
+  | `MSVC64 -> "msvc64.obj"
+  | `CYGWIN -> "cygwin.o"
+  | `CYGWIN64 -> "cygwin64.o"
+  | `MINGW64 -> "mingw64.o"
+  | `GNAT -> "gnat.o"
+  | `GNAT64 -> "gnat64.o"
+  | `MINGW | `LIGHTLD -> "mingw.o" in
+  if !exe_mode <> `DLL then
+    if !add_flexdll_obj then f ("flexdll_" ^ tc) :: files
+    else files
+  else
+    if !noentry then files
+    else f ("flexdll_initer_" ^ tc) :: files
+
+let main () =
+  parse_cmdline ();
+  setup_toolchain ();
+
+  use_cygpath :=
+    begin
+      match !toolchain, !cygpath_arg with
+      | _, `Yes -> true
+      | _, `No -> false
+      | (`GNAT|`GNAT64|`MINGW|`MINGW64|`CYGWIN|`CYGWIN64), `None ->
+          begin match Sys.os_type with
+          | "Unix" | "Cygwin" ->
+              Sys.command "cygpath -S 2>/dev/null >/dev/null" = 0
+          | "Win32" ->
+              Sys.command "cygpath -S 2>NUL >NUL" = 0
+          | _ -> assert false
+          end
+      | (`MSVC|`MSVC64|`LIGHTLD), `None -> false
+    end;
+
+
+  if !verbose >= 2 then (
+    Printf.printf "** Use cygpath: %b\n" !use_cygpath;
+    Printf.printf "** Search path:\n";
+    List.iter print_endline !search_path;
+    if !use_default_libs then begin
+      Printf.printf "** Default libraries:\n";
+      List.iter print_endline !default_libs;
+    end;
+    flush stdout
+   );
+  let files = all_files () in
+  match !mode with
+  | `DUMP -> List.iter dump files
+  | `NORMAL ->
+      build_dll !exe_mode !output_file files !exts (List.rev !extra_args)
+  | `PATCH ->
+      patch_output !output_file
+
+let () =
+  try main ()
+  with
+    | Failure s ->
+        Printf.eprintf "** Fatal error: %s\n" s;
+        exit 2
+    | Invalid_argument s ->
+        Printf.eprintf "** Fatal error: invalid argument (%s)\n" s;
+        exit 2
+    | Arg.Help s ->
+        Printf.printf "%s\n%s\n" s footer;
+        exit 0
+    | Arg.Bad s ->
+        Printf.eprintf "%s\n%s\n" s footer;
+        exit 2
+    | exn ->
+        Printf.eprintf "** Error: %s\n" (Printexc.to_string exn);
+        exit 2
--- ./flexdll/version.rc
+++ ./flexdll/version.rc
@@ -0,0 +1,31 @@
+//#include "afxres.h"
+#include <windows.h>
+
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 0,0,0,40
+ PRODUCTVERSION 0,0,0,40
+ FILEFLAGSMASK 0x3fL
+ FILEFLAGS 0x0L
+ FILEOS 0x40004L
+ FILETYPE 0x1L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "FileVersion", "0.0.0.40"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
